<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Japari Park</title>
    <link>https://ahaochan.github.io/</link>
    <atom:link href="/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>Java</description>
    <pubDate>Wed, 12 Dec 2018 17:48:55 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>ThreadPoolExecutor源码分析</title>
      <link>https://ahaochan.github.io/posts/ThreadPoolExecutor_source_code.html</link>
      <guid>https://ahaochan.github.io/posts/ThreadPoolExecutor_source_code.html</guid>
      <pubDate>Wed, 12 Dec 2018 16:10:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;是一个线程池的实现.&lt;br&gt;&lt;code&gt;Java&lt;/code&gt;提供了&lt;code&gt;Executors&lt;/code&gt;工厂类来创建&lt;code&gt;ExecutorService&lt;/code&gt;线程池实例。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ThreadPoolExecutor</code>是一个线程池的实现.<br><code>Java</code>提供了<code>Executors</code>工厂类来创建<code>ExecutorService</code>线程池实例。</p><a id="more"></a><p><img src="http://yuml.me/diagram/nofunky/class/[&lt;&lt;Executor&gt;&gt;]^-.-[&lt;&lt;ExecutorService&gt;&gt;],[&lt;&lt;ExecutorService&gt;&gt;]^-.-[AbstractExecutorService],[AbstractExecutorService]^-[ThreadPoolExecutor]" alt=""></p><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p><code>ThreadPoolExecutor</code>的构造方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把线程池想象一个水壶, <code>corePoolSize</code>就相当于液面警戒线, 虽然满了还可以再加水, 但是不可能超过水壶的极限高度<code>maximumPoolSize</code>.<br><code>keepAliveTime</code>则是允许线程空闲下来的时间, <code>TimeUnit</code>是时间单位.<br><code>workQueue</code>是阻塞队列, 用于存储超过<code>corePoolSize</code>但是未满<code>maximumPoolSize</code>的线程.<br><code>threadFactory</code>用于创建线程池内的线程, 默认是<code>DefaultThreadFactory</code><br><code>handler</code>是拒绝策略, 用于回调执行添加线程失败的代码. </p><h1 id="线程池内部状态流转"><a href="#线程池内部状态流转" class="headerlink" title="线程池内部状态流转"></a>线程池内部状态流转</h1><p><code>Java</code>中的<code>int</code>类型有<code>32</code>位, <code>ThreadPoolExecutor</code>使用<code>ctl</code>的高<code>3</code>位表示线程池的运行状态, 低<code>29</code>位表示线程池中的线程数.<br>线程池的状态有:</p><ol><li><code>RUNNING</code>: 运行状态, 可以接收任务</li><li><code>SHUTDOWN</code>: 调用了<code>shutdown()</code>方法后的状态, 等待所有任务执行完毕后关闭线程池.</li><li><code>STOP</code>: 调用了<code>shutdownNow()</code>方法后的状态, 强制结束所有任务并关闭线程池.</li><li><code>TIDYING</code>: 空闲状态, 所有任务都执行完毕。</li><li><code>TERMINATED</code>: 终止状态，调用了<code>terminated()</code>方法后的状态.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;      <span class="comment">// 29</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>; <span class="comment">// 11111111111111111111111111111, 29位全1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;    <span class="comment">// 111 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;    <span class="comment">// 000</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;    <span class="comment">// 001</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;    <span class="comment">// 010</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;    <span class="comment">// 011</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Packing and unpacking ctl</span></span><br><span class="line">    <span class="comment">// 获取运行状态, 高3位</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="comment">// 获取线程数量, 低29位</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">    <span class="comment">// 获取 ctl 变量, 组合 高3位 和 低29位</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>下面<code>3</code>个静态方法用于拆分和组合<strong>运行状态</strong>和<strong>线程数量</strong>.<br>假设线程池运行状态为<code>RUNING</code>, 线程池内有<code>2</code>个线程.<br>那么<code>ctl</code>变量的值的二进制形式就是<code>111 00000000000000000000000000010</code>.<br>根据<code>ctl</code>获取运行状态: <code>rs = runStateOf(ctl)</code>得到<code>111 00000000000000000000000000000</code><br>根据<code>ctl</code>获取线程数量: <code>wc = runStateOf(ctl)</code>得到<code>000 00000000000000000000000000010</code><br>如果之后需要根据<code>rs</code>和<code>wc</code>获取<code>ctl</code>, 则调用<code>ctl = ctlOf(rs, wc)</code>得到<code>111 00000000000000000000000000010</code></p><h1 id="添加一个Runnable"><a href="#添加一个Runnable" class="headerlink" title="添加一个Runnable"></a>添加一个Runnable</h1><h2 id="execute-Runnable-command"><a href="#execute-Runnable-command" class="headerlink" title="execute(Runnable command)"></a>execute(Runnable command)</h2><p><code>ThreadPoolExecutor</code>实现了<code>Executor</code>接口的唯一一个方法<code>void execute(Runnable command)</code>;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 1. 判断当前线程数量 是否小于 核心线程数量, 尝试添加线程到核心线程池</span></span><br><span class="line">        <span class="comment">//    添加到核心线程池失败 或者 核心线程池满了, 则继续往下走</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 判断线程池状态是 RUNNING, 往阻塞队列添加这个 Runnable </span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">// 2.1. 判断线程池不是RUNNING, 则从队列删除这个 Runnable, 并调用 reject 回调方法</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">// 2.2. 判断线程池内的线程数量如果为0, 则创建一个非核心线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 如果线程池状态不是 RUNNING, 或者阻塞队列添加失败</span></span><br><span class="line">        <span class="comment">//    尝试添加 Runnable 到非核心线程池, 如果还是失败, 则调用 reject 回调方法</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol><li>只要<code>Core Pool</code>没有填满, 线程池就会一直创建线程到<code>Core Pool</code>中.</li><li>一旦<code>Core Pool</code>填满了, 就添加到阻塞队列(构造函数传入)中.<br> 2.2. 如果添加到阻塞队列成功, 且当前线程池的线程数为0, 则创建一个非<code>Core</code>线程.<ol start="3"><li>如果添加到阻塞队列失败, 尝试创建一个非<code>Core</code>线程, 仍然失败则调用<code>reject</code>处理器(构造函数传入)的回调函数.</li></ol></li></ol><p>简单点说, 线程池会先填满<code>corePoolSize</code>, 再填满队列, 再填满<code>maximumPoolSize</code>, 如果还有则调用<code>reject</code>回调方法.</p><h2 id="addWorker-Runnable-firstTask-boolean-core"><a href="#addWorker-Runnable-firstTask-boolean-core" class="headerlink" title="addWorker(Runnable firstTask, boolean core)"></a>addWorker(Runnable firstTask, boolean core)</h2><p>上面的代码一直围绕着<code>addWorker</code>方法, 这个方法可以创建<code>Core</code>线程和非<code>Core</code>线程.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 省略以上代码, 都是对状态进行判断, 判断是否可以添加 Worker, 不复杂, 就是绕</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">        Worker w = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 创建 Worker 实例, 线程池中的线程都是 Worker</span></span><br><span class="line">            w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">            <span class="keyword">final</span> Thread t = w.thread; <span class="comment">// 这个线程是用 ThreadFactory 创建的</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 3. HashSet 不是线程安全的, 加锁, 添加到 HashSet 中</span></span><br><span class="line">                <span class="comment">// 省略部分代码</span></span><br><span class="line">                <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">                mainLock.lock();</span><br><span class="line">                workers.add(w);</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">                <span class="comment">// 4. 执行线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">                addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> workerStarted;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面代码可以看出, <code>Core</code>线程和非<code>Core</code>线程本质都是一个<code>Worker</code>, 甚至这个<code>Worker</code>都没有属性来标识是否为<code>Core</code>线程, 而是通过一堆线程池状态来判断创建的是<code>Core</code>线程还是非<code>Core</code>线程.</p><p>创建完后就执行这个<code>Worker</code>线程, 从阻塞队列里不停的取任务来执行.</p><h2 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h2><p><code>Worker</code>是<code>ThreadPoolExecutor</code>的内部类.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread; <span class="comment">// ThreadFactory 创建的线程</span></span><br><span class="line">        Runnable firstTask;  <span class="comment">// 提交到线程池里的任务</span></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="runWorker-Worker-w"><a href="#runWorker-Worker-w" class="headerlink" title="runWorker(Worker w)"></a>runWorker(Worker w)</h2><p>间接调用了<code>ThreadPoolExecutor</code>的<code>runWorker</code>方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 先执行Worker的任务, 然后从队列中循环取出任务</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task); <span class="comment">// 交给子类扩展, 空方法体</span></span><br><span class="line">                    task.run();</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">// 交给子类扩展, 空方法体</span></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>直接调用了<code>run</code>方法, 完成线程任务.</p><h2 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h2><p><code>getTask()</code>从阻塞队列中获取提交到线程池的任务.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">            <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 省略跳出循环的代码, timedOut 为 true 则 return null</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Runnable r = timed ?</span><br><span class="line">                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                    workQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                timedOut = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">                timedOut = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>poll</code>方法支持延迟从队列中获取元素, <code>take</code>则马上从队列中获取元素.<br>当超时后, <code>getTask()</code>返回<code>null</code>, 则<code>runWorker</code>方法的无限循环也跑不下去了, 自然就结束了这个线程.</p><p>一个交给线程池的线程就执行完毕了. 省略了很多状态转换的代码, 如果看不懂可以结合源码阅读。</p><h1 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h1><p>关闭线程池有两种方法<code>shutdown()</code>和<code>shutdownNow()</code>.<br>参考资料提到了一种优雅的关闭线程池的方法, 如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    pool.execute(<span class="keyword">new</span> Job());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pool.awaitTermination(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">    logger.info(<span class="string">"线程还在执行。。。"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">logger.info(<span class="string">"一共处理了【&#123;&#125;】"</span>, (end - start));</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/crossoverJie/JCSprout/blob/master/MD/ThreadPoolExecutor.md" target="_blank" rel="noopener">ThreadPoolExecutor</a></li><li><a href="https://blog.csdn.net/u010963948/article/details/80573898" target="_blank" rel="noopener">深入理解Java线程池原理分析与使用（尤其当线程队列满了之后事项）</a></li></ul>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/ThreadPoolExecutor_source_code.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>基于shadowsocks-libev+simple-obfs的单机多用户搭建</title>
      <link>https://ahaochan.github.io/posts/multi_user_of_shadowsocks_libev.html</link>
      <guid>https://ahaochan.github.io/posts/multi_user_of_shadowsocks_libev.html</guid>
      <pubDate>Tue, 11 Dec 2018 12:11:33 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;基于&lt;a href=&quot;https://github.com/shadowsocks/shadowsocks-libev&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;shadowsocks-libev&lt;/a&gt;+&lt;a href=&quot;https://github.com/shadowsocks/simple-obfs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;simple-obfs&lt;/a&gt;的单机多用户搭建。&lt;br&gt;本文基于&lt;code&gt;Ubuntu 18.04&lt;/code&gt;在虚拟机中进行操作, 并于&lt;code&gt;VPS&lt;/code&gt;上测试成功。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基于<a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">shadowsocks-libev</a>+<a href="https://github.com/shadowsocks/simple-obfs" target="_blank" rel="noopener">simple-obfs</a>的单机多用户搭建。<br>本文基于<code>Ubuntu 18.04</code>在虚拟机中进行操作, 并于<code>VPS</code>上测试成功。</p><a id="more"></a><h1 id="允许root远程登录"><a href="#允许root远程登录" class="headerlink" title="允许root远程登录"></a>允许root远程登录</h1><p>使用<code>root</code>避免各种权限问题, 实际使用时应登录普通用户后<code>sudo -s</code>切换到<code>root</code>用户。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo passwd root</span><br><span class="line">sudo sed -i <span class="string">'s/#PermitRootLogin prohibit-password/PermitRootLogin yes/'</span> /etc/ssh/sshd_config</span><br><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure></p><h1 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h1><p>服务端使用<a href="https://github.com/shadowsocks/shadowsocks-libev" target="_blank" rel="noopener">shadowsocks-libev</a>, 其他项目似乎都好久没更新了。<br><a href="https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/shadowsocks-libev.asciidoc#config-file" target="_blank" rel="noopener">配置文件官方文档</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装 shadowsocks-libev</span></span><br><span class="line">sudo apt update -y</span><br><span class="line">sudo apt install shadowsocks-libev -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加配置文件</span></span><br><span class="line">sudo mkdir /opt/config</span><br><span class="line">sudo vim /opt/config/manager.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"port_password"</span>: &#123;</span><br><span class="line">    <span class="string">"443"</span>: <span class="string">"12345"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"fast_open"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">"reuse_port"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">"no_delay"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">"timeout"</span>: 300,</span><br><span class="line">  <span class="string">"mode"</span>:<span class="string">"tcp_and_udp"</span>,</span><br><span class="line">  <span class="string">"method"</span>: <span class="string">"aes-256-gcm"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 启动</span></span><br><span class="line">sudo ss-manager -c /opt/config/manager.json</span><br></pre></td></tr></table></figure></p><p>客户端连接上, 然后开启全局模式, 执行如下操作</p><ol><li>访问<code>www.baidu.com</code>, 访问成功</li><li>关闭服务端, 访问<code>www.baidu.com</code>, 访问失败</li></ol><p>则说明<code>shadowsocks-libev</code>已经成功配置。</p><h1 id="配置-simple-obfs-混淆插件"><a href="#配置-simple-obfs-混淆插件" class="headerlink" title="配置 simple-obfs 混淆插件"></a>配置 simple-obfs 混淆插件</h1><h2 id="服务端配置-1"><a href="#服务端配置-1" class="headerlink" title="服务端配置"></a>服务端配置</h2><p><a href="https://github.com/shadowsocks/simple-obfs" target="_blank" rel="noopener">simple-obfs</a> 是一个简单的混淆插件, 可以伪装成 <code>http</code> 流量。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 从 Github 下载源码进行编译</span></span><br><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">apt-get install --no-install-recommends build-essential autoconf libtool libssl-dev libpcre3-dev libev-dev asciidoc xmlto automake -y</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/shadowsocks/simple-obfs.git</span><br><span class="line"><span class="built_in">cd</span> simple-obfs</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure &amp;&amp; make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加配置文件, 添加 plugin 和 plugin_opts 参数</span></span><br><span class="line">sudo vim /opt/config/manager.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"port_password"</span>: &#123;</span><br><span class="line">    <span class="string">"443"</span> : <span class="string">"12345"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"fast_open"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">"reuse_port"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">"no_delay"</span>:<span class="literal">true</span>,</span><br><span class="line">  <span class="string">"timeout"</span>: 300,</span><br><span class="line">  <span class="string">"mode"</span>:<span class="string">"tcp_and_udp"</span>,</span><br><span class="line">  <span class="string">"method"</span>: <span class="string">"aes-256-gcm"</span>,</span><br><span class="line">  <span class="string">"plugin"</span>:<span class="string">"obfs-server"</span>,</span><br><span class="line">  <span class="string">"plugin_opts"</span>:<span class="string">"obfs=http;failover=apps.bdimg.com"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 重启 shadowsocks-libev</span></span><br><span class="line">systemctl restart shadowsocks-libev</span><br></pre></td></tr></table></figure></p><h2 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h2><p><code>win</code>: <a href="https://github.com/shadowsocks/simple-obfs/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/simple-obfs/releases</a><br>复制到客户端同一目录下, 并配置以下参数<br>插件程序: <code>obfs-local</code><br>插件选项: <code>obfs=http</code><br>插件参数: <code>obfs-host=apps.bdimg.com</code></p><p><code>android</code>: <a href="https://github.com/shadowsocks/simple-obfs-android/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/simple-obfs-android/releases</a></p><p>没有苹果设备, 不做研究。</p><h1 id="流量统计"><a href="#流量统计" class="headerlink" title="流量统计"></a>流量统计</h1><p><del><a href="https://github.com/shadowsocks/shadowsocks-manager" target="_blank" rel="noopener">shadowsocks-manager</a>要部署邮箱才行, 放弃.</del><br><del><a href="https://github.com/shadowsocks/shadowsocks-hub" target="_blank" rel="noopener">shadowsocks-hub</a>依赖于<a href="https://github.com/shadowsocks/shadowsocks-restful-api" target="_blank" rel="noopener">shadowsocks-restful-api</a>, 也是依赖于原生的<code>manager API</code>接口.(虽然我跑<code>docker</code>失败了)</del></p><p><code>shadowsocks-libev</code>提供了原生的<code>manager API</code>接口, 可以统计流量使用情况.接口文档在这里<a href="https://github.com/shadowsocks/shadowsocks-libev/blob/master/doc/ss-manager.asciidoc#protocol" target="_blank" rel="noopener">protocol</a>.</p><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="开启BBR"><a href="#开启BBR" class="headerlink" title="开启BBR"></a>开启BBR</h2><p><code>BBR</code>需要内核<code>4.9</code>以上.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查看内核</span></span><br><span class="line">uname -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 启动BBR</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.core.default_qdisc=fq"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_congestion_control=bbr"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line">lsmod | grep bbr</span><br></pre></td></tr></table></figure></p><h2 id="部署一个正常的网站到80端口"><a href="#部署一个正常的网站到80端口" class="headerlink" title="部署一个正常的网站到80端口"></a>部署一个正常的网站到80端口</h2><p>也可以用来部署一些自己的<code>web</code>应用<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install apache2 -y</span><br><span class="line">service apache2 start</span><br></pre></td></tr></table></figure></p><h2 id="封禁恶意访问IP"><a href="#封禁恶意访问IP" class="headerlink" title="封禁恶意访问IP"></a>封禁恶意访问IP</h2><p>使用 <code>fail2ban</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装 fail2ban</span></span><br><span class="line">apt install fail2ban -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. ssh 安全规则</span></span><br><span class="line">vim /etc/fail2ban/jail.d/ssh.conf</span><br><span class="line">[ssh-iptables]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">filter     = sshd</span><br><span class="line">action   = iptables[name=SSH, port=ssh, protocol=tcp]</span><br><span class="line">logpath = /var/<span class="built_in">log</span>/secure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. apache 安全规则</span></span><br><span class="line">vim /etc/fail2ban/jail.d/apache.conf</span><br><span class="line">[apache-tcpwrapper]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">filter     = apache-auth</span><br><span class="line">action   = hostdeny</span><br><span class="line">logpath = /var/<span class="built_in">log</span>/httpd/error_log</span><br><span class="line"></span><br><span class="line">[apache-badbots]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">filter     = apache-badbots</span><br><span class="line">action   = iptables-multiport[name=BadBots, pory=<span class="string">"http,https"</span>]</span><br><span class="line">logpath = /var/<span class="built_in">log</span>/httpd/access_log</span><br><span class="line"></span><br><span class="line">[apache-shorewall]</span><br><span class="line">enabled = <span class="literal">true</span></span><br><span class="line">filter     = apache-noscript</span><br><span class="line">action   = shorewall</span><br><span class="line">logpath = /var/<span class="built_in">log</span>/httpd/error_log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 重启服务</span></span><br><span class="line">service fail2ban restart</span><br></pre></td></tr></table></figure></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>吐槽下, <code>libev</code>关于<code>config.json</code>的配置没有一个完整的<code>example</code>, 也没有<code>wiki</code>页, 还是我翻了下<code>issue</code>才发现了文档位置. 并且有些参数配置在<code>config.json</code>还没有对应位置.</p><p>开发者觉得我弄出来能用就好了, 不懂就去看源码全在那.<br>小白则是素质三连, 怎么用不了了, 报错了, 打不开怎么办.</p><p>开源不易, 珍惜每个用心写文档的开发者和每个用心写复现步骤的小白.</p>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/multi_user_of_shadowsocks_libev.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>MongoDB学习笔记</title>
      <link>https://ahaochan.github.io/posts/MongoDB_simple_use.html</link>
      <guid>https://ahaochan.github.io/posts/MongoDB_simple_use.html</guid>
      <pubDate>Fri, 07 Dec 2018 07:48:55 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;mongodb&lt;/code&gt;是一个&lt;code&gt;NoSQL&lt;/code&gt;数据库, 可以分词查询, 可以基于地理位置查询, 记录以&lt;code&gt;JSON&lt;/code&gt;形式存储.&lt;br&gt;&lt;code&gt;mongodb&lt;/code&gt;的数据表又叫做数据集合, 关键字为&lt;code&gt;collection&lt;/code&gt;.&lt;br&gt;&lt;code&gt;mongodb&lt;/code&gt;是不存在&lt;code&gt;join&lt;/code&gt;这个概念的, 所以一切的关联查询都得通过外部程序来做.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>mongodb</code>是一个<code>NoSQL</code>数据库, 可以分词查询, 可以基于地理位置查询, 记录以<code>JSON</code>形式存储.<br><code>mongodb</code>的数据表又叫做数据集合, 关键字为<code>collection</code>.<br><code>mongodb</code>是不存在<code>join</code>这个概念的, 所以一切的关联查询都得通过外部程序来做.</p><a id="more"></a><h1 id="安装配置-基于v3-4-18"><a href="#安装配置-基于v3-4-18" class="headerlink" title="安装配置(基于v3.4.18)"></a>安装配置(基于v3.4.18)</h1><p>安装教程: <a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-red-hat/" target="_blank" rel="noopener">Install MongoDB Community Edition on Red Hat Enterprise or CentOS Linux</a>(国内可以用阿里云<code>yum</code>镜像).<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装</span></span><br><span class="line">yum install -y mongodb-org</span><br><span class="line"><span class="comment"># 2. 初始化</span></span><br><span class="line">mkdir -p /opt/mongodb/data/db /opt/mongodb/<span class="built_in">log</span></span><br><span class="line">cp /etc/mongod.conf /opt/mongodb/mongod.conf</span><br><span class="line"><span class="comment"># 3. 修改配置文件</span></span><br><span class="line">sed -i <span class="string">'s#/var/log/mongodb/mongod.log#/opt/mongodb/log/mongod.log#g'</span> /opt/mongodb/mongod.conf</span><br><span class="line">sed -i <span class="string">'s#/var/lib/mongo#/opt/mongodb/data/db#g'</span> /opt/mongodb/mongod.conf</span><br><span class="line">sed -i <span class="string">'s#/var/run/mongodb/mongod.pid#/opt/mongodb/mongod.pid#g'</span> /opt/mongodb/mongod.conf</span><br><span class="line"><span class="comment"># 4. 查看版本号</span></span><br><span class="line">mongod --version</span><br><span class="line"><span class="comment"># 5. 启动</span></span><br><span class="line">mongod -f /opt/mongodb/mongod.conf</span><br><span class="line"><span class="comment"># 6. 关闭</span></span><br><span class="line">mongo 127.0.0.1:27071/<span class="built_in">test</span></span><br><span class="line">use admin <span class="comment"># 使用 admin 数据库</span></span><br><span class="line">db.shutdownServer()</span><br></pre></td></tr></table></figure></p><h1 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h1><h2 id="auth-用户名密码登录"><a href="#auth-用户名密码登录" class="headerlink" title="auth 用户名密码登录"></a>auth 用户名密码登录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建用户</span></span><br><span class="line">db.createUser(&#123;</span><br><span class="line">  user: <span class="string">"ahao"</span>,</span><br><span class="line">  <span class="built_in">pwd</span>: <span class="string">"ahao"</span>,</span><br><span class="line">  customData: &#123;msg:<span class="string">"我是一个新用户"</span>&#125;,</span><br><span class="line">  roles:[&#123;role:<span class="string">"dbOwner"</span>, db:<span class="string">"admin"</span>&#125;]</span><br><span class="line">&#125;)</span><br><span class="line">角色类型: <span class="built_in">read</span>、readWrite、dbAdmin、dbOwner、userAdmin</span><br><span class="line">dbOwner = <span class="built_in">read</span> + readWrite + dbAdmin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 开启auth验证, 修改 /opt/mongodb/mongodb.conf</span></span><br><span class="line">system:</span><br><span class="line">  authorization: enabled</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 3. 启动, 查询所有用户</span></span><br><span class="line">mongod -f /opt/mongodb/mongodb.conf</span><br><span class="line">mongo 127.0.0.1:12345 -u ahao -p ahao</span><br><span class="line">use admin</span><br><span class="line">db.system.users.find()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 创建角色</span></span><br><span class="line">db.createRole(&#123;</span><br><span class="line">  _id: <span class="string">"唯一id"</span>,</span><br><span class="line">  role: <span class="string">"角色名"</span>,</span><br><span class="line">  db: <span class="string">"数据库名"</span>,</span><br><span class="line">  privileges: [</span><br><span class="line">    &#123; resource:&#123;db:<span class="string">"数据库名"</span>, collection:<span class="string">"集合名"</span>, actions:[允许执行的操作]&#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">  roles: [继承哪些角色]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="集群keyfile"><a href="#集群keyfile" class="headerlink" title="集群keyfile"></a>集群keyfile</h2><p>keyfile文件认证</p><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p><code>mongodb</code>数据库不用新建, 直接<code>use</code>, 数据库会在插入记录的时候自动创建数据库及数据集合.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 新建数据库(插入记录时自动创建数据库及数据集合)</span></span><br><span class="line">use test_db</span><br><span class="line">db.test_collection.insert(&#123;x:1&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 显示数据库</span></span><br><span class="line">show dbs</span><br><span class="line">  admin   0.000GB</span><br><span class="line">  <span class="built_in">local</span>   0.000GB</span><br><span class="line">  test_db 0.000GB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除数据库</span></span><br><span class="line">use test_db</span><br><span class="line">db.dropDatabase()</span><br></pre></td></tr></table></figure></p><h1 id="表collection"><a href="#表collection" class="headerlink" title="表collection"></a>表collection</h1><p>同样, 数据表也是在插入时自动创建.<br>和关系型数据库不同, 不需要提前设置字段.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 切换到 test 数据库</span></span><br><span class="line">use test_db</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 创建数据表(插入记录时自动创建)</span></span><br><span class="line">show collections <span class="comment"># 没有表</span></span><br><span class="line">db.test_collection.insert(&#123;x:1&#125;)</span><br><span class="line">show collections</span><br><span class="line">  test_collection</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除数据表</span></span><br><span class="line">&gt; db.test_collection.drop()</span><br></pre></td></tr></table></figure></p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>在<code>v3.0.0</code>后, <a href="https://docs.mongodb.com/manual/reference/method/db.collection.ensureIndex/" target="_blank" rel="noopener">官方文档</a>提到创建索引的函数<code>createIndex()</code>替换掉了<code>ensureIndex()</code>. 当然非要使用<code>ensureIndex()</code>也是可以的.<br>创建索引的格式: <code>db.集合名.createIndex({索引值}, {索引属性})</code></p><table><thead><tr><th style="text-align:center">索引属性</th><th style="text-align:center">语法</th><th style="text-align:center">默认</th></tr></thead><tbody><tr><td style="text-align:center">名称</td><td style="text-align:center"><code>db.集合名.createIndex({索引值}, {name:&quot;索引名称&quot;})</code></td><td style="text-align:center"><code>字段名_1</code>或<code>字段名_-1</code></td></tr><tr><td style="text-align:center">唯一性</td><td style="text-align:center"><code>db.集合名.createIndex({索引值}, {unique:[true or false]})</code></td><td style="text-align:center"><code>false</code></td></tr><tr><td style="text-align:center">稀疏性</td><td style="text-align:center"><code>db.集合名.createIndex({索引值}, {sparse:[true or false]})</code></td><td style="text-align:center"><code>true</code>, 避免为插入记录不存在的字段创建索引</td></tr><tr><td style="text-align:center">是否定时删除</td><td style="text-align:center"><code>db.集合名.createIndex({索引值}, {expireAfterSeconds:秒数})</code></td><td style="text-align:center">不删除</td></tr></tbody></table><h2 id="没有属性的普通索引"><a href="#没有属性的普通索引" class="headerlink" title="没有属性的普通索引"></a>没有属性的普通索引</h2><table><thead><tr><th style="text-align:center">索引类型</th><th style="text-align:center">说明</th><th style="text-align:center">创建方法(1为正序, -1为逆序)</th></tr></thead><tbody><tr><td style="text-align:center"><code>_id</code>索引</td><td style="text-align:center">自动创建的索引, 作为记录的唯一主键</td><td style="text-align:center"><code>db.test_collection.insert({name:1})</code></td></tr><tr><td style="text-align:center">单键索引</td><td style="text-align:center">为一个字段创建的索引, 字段值为<strong>单个</strong>元素</td><td style="text-align:center"><code>db.test_collection.createIndex({name:1})</code></td></tr><tr><td style="text-align:center">多键索引</td><td style="text-align:center">为一个字段创建的索引, 字段值为<strong>数组</strong>元素</td><td style="text-align:center"><code>db.test_collection.createIndex({class:1})</code></td></tr><tr><td style="text-align:center">复合索引</td><td style="text-align:center">为<strong>多个</strong>字段创建的索引</td><td style="text-align:center"><code>db.test_collection.createIndex({name:1, age:1})</code></td></tr></tbody></table><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 test 数据库</span></span><br><span class="line">use test_db</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 查看索引, 格式: db.数据集合.getIndexes()</span></span><br><span class="line">db.test_collection.getIndexes()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. _id索引自动创建, 每条插入的数据都会自动生成一个`_id`字段, 作为`key`.</span></span><br><span class="line">db.test_collection.insert(&#123;name:<span class="string">"Tom"</span>, age:12, friends:[<span class="string">"Sum"</span>, <span class="string">"Kim"</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 创建索引, 格式: db.数据表.createIndex(&#123;索引字段: [1|-1]&#125;), 1为正序, -1为逆序</span></span><br><span class="line"><span class="comment">## 单个元素的单键索引</span></span><br><span class="line">db.test_collection.createIndex(&#123;name:1&#125;)</span><br><span class="line"><span class="comment">## 多个元素的多键索引</span></span><br><span class="line">db.test_collection.createIndex(&#123;friends:1&#125;)</span><br><span class="line"><span class="comment">## 多个字段的复合索引</span></span><br><span class="line">db.test_collection.createIndex(&#123;name:1, age:1&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 删除索引</span></span><br><span class="line">db.test_collection.dropIndex(<span class="string">"索引名"</span>)</span><br></pre></td></tr></table></figure><h2 id="过期索引TTL"><a href="#过期索引TTL" class="headerlink" title="过期索引TTL"></a>过期索引TTL</h2><p>一定时间后会过期的索引, 存储的值必须是时间类型, 如<code>new Date()</code>. 如果是数组, 则取最小的时间.<br>一个字段不能同时有过期索引和复合索引. </p><p>当数据过期时, 对应的数据会自动删除. 但是<code>mongodb</code>删除任务<code>60</code>秒执行一次, 所以过期时间最好不要小于<code>60</code>秒.<br>适用于登录信息、日志信息、缓存等不重要的信息.<br>创建语法: <code>db.数据集合.createIndex({时间字段:1}, {expireAfterSeconds:秒数})</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化数据</span></span><br><span class="line">use test_db</span><br><span class="line">db.login_info.insert(&#123;name:<span class="string">"Tom"</span>, login_time:new Date()&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建索引, 10秒后过期</span></span><br><span class="line">db.login_info.createIndex(&#123;login_time:1&#125;, &#123;expireAfterSeconds:10&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待过期后, 查询不到过期数据</span></span><br><span class="line">db.login_info.find()</span><br></pre></td></tr></table></figure></p><h2 id="文本索引"><a href="#文本索引" class="headerlink" title="文本索引"></a>文本索引</h2><p>说是文本索引, 其实就是对选择的字段进行分词索引. 所选的字段可以一个, 也可以多个.<br>一个数据集只有一个文本索引, 且只能是字符串类型的字段.<br>查询文本索引时, 不允许使用<code>hint()</code>指定索引进行查询.<br>创建语法: <code>db.数据集合.createIndex({字段:&quot;text&quot;})</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单个字段的文本索引</span></span><br><span class="line">db.test_collection.createIndex(&#123;name:<span class="string">"text"</span>&#125;)</span><br><span class="line"><span class="comment"># 多个字段的文本索引</span></span><br><span class="line">db.test_collection.createIndex(&#123;name:<span class="string">"text"</span>, address:<span class="string">"text"</span>&#125;)</span><br><span class="line"><span class="comment"># 所有字段的文本索引</span></span><br><span class="line">db.test_collection.createIndex(&#123;<span class="string">"$**"</span>:<span class="string">"text"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>查询语法, 多个关键字用空格分隔, 默认为<code>or</code>查询.<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">语法</span><br><span class="line">db.test_collection.find(&#123;</span><br><span class="line">  <span class="variable">$text</span>: &#123;</span><br><span class="line">    <span class="variable">$search</span>: 搜索字符串, </span><br><span class="line">    <span class="variable">$language</span>: 指定语言(社区版不支持中文),</span><br><span class="line">    <span class="variable">$caseSensitive</span>: 是否大小写敏感(默认<span class="literal">false</span>),</span><br><span class="line">    <span class="variable">$diacriticSensitive</span>: 是否区别发音符号(默认<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询单个关键词, 匹配包含hello或world的文本</span></span><br><span class="line">db.test_collection.find(&#123;<span class="variable">$text</span>:&#123;<span class="variable">$search</span>:<span class="string">"hello world"</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 查询单个关键词, 匹配包含hello world的文本</span></span><br><span class="line">db.test_collection.find(&#123;<span class="variable">$text</span>:&#123;<span class="variable">$search</span>:<span class="string">"\"hello world\""</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 查询多个关键词, 匹配包含hello且不包含world的文本</span></span><br><span class="line">db.test_collection.find(&#123;<span class="variable">$text</span>:&#123;<span class="variable">$search</span>:<span class="string">"hello -world"</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 查询多个关键词, 查询包含ssl certificate 且 包含authority或key或ssl或certificate中任意一个 的文本</span></span><br><span class="line">db.test_collection.find(&#123;<span class="variable">$text</span>:&#123;<span class="variable">$search</span>:<span class="string">"\"ssl certificate\" authority key"</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 文本相似度排序</span></span><br><span class="line">db.test_collection.find(&#123;<span class="variable">$text</span>:&#123;<span class="variable">$search</span>:<span class="string">"hello"</span>&#125;&#125;, &#123;score:&#123;<span class="variable">$meta</span>:<span class="string">"textScore"</span>&#125;&#125;).sort(&#123;score:&#123;<span class="variable">$meta</span>:<span class="string">"textScore"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="2d地理位置索引-平面"><a href="#2d地理位置索引-平面" class="headerlink" title="2d地理位置索引(平面)"></a>2d地理位置索引(平面)</h2><p>插入语法: <code>db.数据集合.insert({字段名:[经度(-180,180), 纬度(-90,90)]})</code><br>创建语法: <code>db.数据集合.createIndex({字段:&quot;2d&quot;},{min:最小值,max:最大值,bits:精度(默认26) })</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $near查询距离(10,20)最近的点</span></span><br><span class="line">db.test_location.find(&#123;loc:&#123;<span class="variable">$near</span>:[10,20]&#125;&#125;)</span><br><span class="line"><span class="comment"># $near查询距离(10,20)最近的10个点</span></span><br><span class="line">db.test_location.find(&#123;loc:&#123;<span class="variable">$near</span>:[10,20]&#125;&#125;).<span class="built_in">limit</span>(10)</span><br><span class="line"><span class="comment"># $near查询距离(10,20)最大距离为10的点</span></span><br><span class="line">db.test_location.find(&#123;loc:&#123;<span class="variable">$near</span>:[10,20], <span class="variable">$maxDistance</span>:10&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># $geoWithin 查询某个形状内的点</span></span><br><span class="line"><span class="comment"># 查询对角坐标为(1,2),(3,4)组成的矩形内的点</span></span><br><span class="line">db.test_location.find(&#123;loc:&#123;<span class="variable">$geoWithin</span>:&#123;<span class="variable">$box</span>:[[1,2],[3,4]]&#125;&#125;&#125;)</span><br><span class="line"><span class="comment"># 查询圆心坐标为(1,2), 半径为3的圆内的点</span></span><br><span class="line">db.test_location.find(&#123;loc:&#123;<span class="variable">$geoWithin</span>:&#123;<span class="variable">$center</span>:[[1,2], 3]&#125;&#125;&#125;)</span><br><span class="line"><span class="comment"># 查询坐标为(1,2),(1,10),(2,10),(1,5)组成的多边形内的点</span></span><br><span class="line">db.test_location.find(&#123;loc:&#123;<span class="variable">$geoWithin</span>:&#123;<span class="variable">$polygon</span>:[[1,2], [1,10], [2,10], [1,5]]&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回更多数据的查询</span></span><br><span class="line">db.runCommand(&#123;</span><br><span class="line">    geoNear: 集合名,</span><br><span class="line">    near: [x,y],</span><br><span class="line">    minDistance: 最小距离(对2d索引无效, 对2dsphere索引有效),</span><br><span class="line">    maxDistance: 最大距离</span><br><span class="line">    num: 数量</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h2 id="2dsphere地理位置索引-球面"><a href="#2dsphere地理位置索引-球面" class="headerlink" title="2dsphere地理位置索引(球面)"></a>2dsphere地理位置索引(球面)</h2><p>插入语法: <code>db.数据集合.insert({字段名:{type:&quot;Point&quot;,coordinates:[经度(-180,180), 纬度(-90,90)]}})</code><br>创建语法: <code>db.数据集合.createIndex({字段:&quot;2dsphere&quot;})</code><br>点用<code>GeoJSON</code>的形式表示, 参考<a href="https://docs.mongodb.com/manual/reference/geojson/" target="_blank" rel="noopener">GeoJSON Objects</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回更多数据的查询</span></span><br><span class="line">db.runCommand(&#123;</span><br><span class="line">    geoNear: 集合名,</span><br><span class="line">    near: GeoJSON形式的值,</span><br><span class="line">    minDistance: 最小距离(对2d索引无效, 对2dsphere索引有效),</span><br><span class="line">    maxDistance: 最大距离</span><br><span class="line">    num: 数量</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h1 id="插入更新删除"><a href="#插入更新删除" class="headerlink" title="插入更新删除"></a>插入更新删除</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 插入数据, 格式: db.数据表.insert(json);</span></span><br><span class="line"><span class="comment"># 插入单条数据</span></span><br><span class="line">&gt; db.test_collection.insert(&#123;name:<span class="string">"小明"</span>, age: 10&#125;)</span><br><span class="line"><span class="comment"># 插入多条数据</span></span><br><span class="line">&gt; <span class="keyword">for</span>(i=1;i&lt;3;i++) db.test_collection.insert(&#123;name:<span class="string">"name"</span>+i, age:i&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 更新数据, 格式: db.数据表.update(查询条件, 修改后的值, 是否不存在则插入, 是否批量更新);</span></span><br><span class="line"><span class="comment">## 会覆盖所有字段, age 字段会删除</span></span><br><span class="line">&gt; db.test_collection.update(&#123;name:<span class="string">"小明"</span>&#125;, &#123;name:<span class="string">"新名字"</span>&#125;)</span><br><span class="line"><span class="comment">## 只更新 name 字段, age 字段不会更新</span></span><br><span class="line">&gt; db.test_collection.update(&#123;name:<span class="string">"小明"</span>&#125;, &#123;<span class="variable">$set</span>&#123;name:<span class="string">"新名字"</span>&#125;&#125;)</span><br><span class="line"><span class="comment">## 不存在则插入数据</span></span><br><span class="line">&gt; db.test_collection.update(&#123;name:<span class="string">"小红"</span>&#125;, &#123;name:<span class="string">"新小红"</span>, age: 11&#125;, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">## 批量更新</span></span><br><span class="line">&gt; db.test_collection.update(&#123;age:10&#125;, &#123;<span class="variable">$set</span>&#123;age: 21&#125;&#125;, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 删除数据</span></span><br><span class="line">&gt; db.test_collection.remove(&#123;age:21&#125;)</span><br></pre></td></tr></table></figure><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有数据</span></span><br><span class="line">db.test_collection.find()</span><br><span class="line"><span class="comment"># 查询总数</span></span><br><span class="line">db.test_collection.find().count()</span><br><span class="line"><span class="comment"># 查询第4条到第7条数据, 按name倒序排序</span></span><br><span class="line">db.test_collection.find().skip(3).<span class="built_in">limit</span>(4).sort(&#123;name: -1&#125;)</span><br><span class="line"><span class="comment"># 查询一条数据</span></span><br><span class="line">db.test_collection.findOne(&#123;name:<span class="string">"小明"</span>&#125;)</span><br><span class="line"><span class="comment"># 查询存在某个字段的记录</span></span><br><span class="line">&gt; db.test_collection.find(&#123;x:&#123;<span class="variable">$exists</span>:<span class="literal">true</span>&#125;&#125;)</span><br><span class="line"><span class="comment"># 按写入顺序逆序10条记录</span></span><br><span class="line">&gt; db.test_collection.find().sort(&#123;<span class="variable">$natural</span>:-1&#125;).<span class="built_in">limit</span>(10)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/MongoDB_simple_use.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>自动转型带来的NoSuchMethodError</title>
      <link>https://ahaochan.github.io/posts/NoSuchMethodError_caused_by_Automatic_Type_Conversion.html</link>
      <guid>https://ahaochan.github.io/posts/NoSuchMethodError_caused_by_Automatic_Type_Conversion.html</guid>
      <pubDate>Tue, 04 Dec 2018 09:03:16 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;更新了&lt;code&gt;core&lt;/code&gt;包里的通用方法, 结果本地代码没问题, 线上代码&lt;code&gt;500&lt;/code&gt;, 看了下&lt;code&gt;localhost.log&lt;/code&gt;, 发现报&lt;code&gt;NoSuchMethodError&lt;/code&gt;. 特此记录下。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>更新了<code>core</code>包里的通用方法, 结果本地代码没问题, 线上代码<code>500</code>, 看了下<code>localhost.log</code>, 发现报<code>NoSuchMethodError</code>. 特此记录下。</p><a id="more"></a><h1 id="重现步骤"><a href="#重现步骤" class="headerlink" title="重现步骤"></a>重现步骤</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> page = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> pageSize = <span class="number">10</span>;</span><br><span class="line">        Utils.test(page,pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Utils.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> pageSize)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"page:"</span>+page+<span class="string">", pageSize:"</span>+pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译<code>javac Main.java Utils.java</code><br>运行<code>java Main</code>后输出<code>page:1, pageSize:10</code><br>修改<code>Utils</code>代码, 将<code>int</code>改为<code>long</code>, <code>Main</code>不用改动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> page, <span class="keyword">int</span> pageSize)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第"</span>+page+<span class="string">"页, 分页大小为"</span>+pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只编译<code>Utils</code>, 执行<code>javac Utils.java</code><br>然后运行<code>java Main</code>, 抛出<code>NoSuchMethodError</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.NoSuchMethodError: Utils.test(II)V</span><br><span class="line">        at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure></p><p>重新同时编译两个文件<code>javac Main.java Utils.java</code><br>运行<code>java Main</code>后又成功输出<code>page:1, pageSize:10</code></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>先把修改前的<code>class</code>文件反编译, 得到如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> var2 = <span class="number">10</span>;</span><br><span class="line">        Utils.test(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Utils.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> var0, <span class="keyword">int</span> var1)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"page:"</span> + var0 + <span class="string">", pageSize:"</span> + var1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将<code>Utils</code>的<code>int</code>转为<code>long</code>之后进行反编译得到如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> var2 = <span class="number">10</span>;</span><br><span class="line">        Utils.test(var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Utils.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> var0, <span class="keyword">int</span> var2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"page:"</span> + var0 + <span class="string">", pageSize:"</span> + var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同时编译<code>Main.java</code>和<code>Utils.java</code>之后进行反编译得到如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> var2 = <span class="number">10</span>;</span><br><span class="line">        Utils.test((<span class="keyword">long</span>)var1, var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Utils.class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Utils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> var0, <span class="keyword">int</span> var2)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"page:"</span> + var0 + <span class="string">", pageSize:"</span> + var2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对比可以看到, 正常执行的代码, <code>page</code>参数的类型是对应的, 自动转型其实是在编译的时候对其进行了强制转换.<br>当我们修改了方法参数类型后, 只编译部署<code>Utils.class</code>后, <code>Main</code>就找不到符合<code>test(int, int)</code>的方法, 因为<code>Utils.class</code>只有<code>test(long, int)</code>方法。<br>而当我们两个类都进行编译时, <code>Main</code>检测到<code>Utills.class</code>没有<code>test(int, int)</code>, 就会自动在调用的方法里加上强制类型转换<code>(long) var1</code>.</p><h1 id="发生的情景"><a href="#发生的情景" class="headerlink" title="发生的情景"></a>发生的情景</h1><p>一般发生在增量更新的项目里面, 本地编译了<code>class</code>文件, 只替换服务器上对应的文件, 如果是全量更新的项目, 则不会出现这个问题。</p><h1 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h1><p>有两种方法</p><ol><li>全量更新</li><li>保留旧的代码, 添加<code>@Deprecated</code>注解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utils.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> page, <span class="keyword">int</span> pageSize)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"page:"</span>+page+<span class="string">", pageSize:"</span>+pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> page, <span class="keyword">int</span> pageSize)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"page:"</span>+page+<span class="string">", pageSize:"</span>+pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/NoSuchMethodError_caused_by_Automatic_Type_Conversion.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx配置多个域名</title>
      <link>https://ahaochan.github.io/posts/Nginx_configures_multiple_server_name.html</link>
      <guid>https://ahaochan.github.io/posts/Nginx_configures_multiple_server_name.html</guid>
      <pubDate>Mon, 03 Dec 2018 08:25:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;解决&lt;code&gt;Cookie&lt;/code&gt;跨域请求的时候, 发现这样一个&lt;a href=&quot;https://scripts.cmbuckley.co.uk/cookies.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网站scripts.cmbuckley.co.uk&lt;/a&gt;, 它拥有无限的子域名, 比如&lt;code&gt;a.scripts.cmbuckley.co.uk&lt;/code&gt;、&lt;code&gt;b.scripts.cmbuckley.co.uk&lt;/code&gt;、&lt;code&gt;hhhhh.scripts.cmbuckley.co.uk&lt;/code&gt;.&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>解决<code>Cookie</code>跨域请求的时候, 发现这样一个<a href="https://scripts.cmbuckley.co.uk/cookies.php" target="_blank" rel="noopener">网站scripts.cmbuckley.co.uk</a>, 它拥有无限的子域名, 比如<code>a.scripts.cmbuckley.co.uk</code>、<code>b.scripts.cmbuckley.co.uk</code>、<code>hhhhh.scripts.cmbuckley.co.uk</code>.</p><a id="more"></a><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>这里用本地环境测试, 在虚拟机搭建一个<code>Nginx</code>服务器.<br><code>Nginx</code>的<code>server_name</code>在<code>server</code>块里面配置, 用于配置基于名称的虚拟主机。<br>比如<code>/etc/nginx/conf.d/default.conf</code>中配置的就是<code>localhost</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们修改<code>hosts</code>, 把<code>localhost</code>指向服务器的<code>IP</code>, 然后访问<code>http://localhost:80</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.94.189 localhost</span><br></pre></td></tr></table></figure></p><p>浏览器发送的请求头会携带一个<code>Host</code>参数<code>localhost</code>, <code>Nginx</code>根据这个<code>Host</code>将请求分发到名为<code>localhost</code>的<code>server</code>进行处理。<br>如果有多个<code>server</code>, 则会按从上到下的顺序一个个匹配, 如果都匹配不到, 则默认交给第一个请求, 或者也可以指定<code>default_server</code>.</p><h1 id="各种server-name"><a href="#各种server-name" class="headerlink" title="各种server_name"></a>各种server_name</h1><p><code>server_name</code>支持精确匹配, 支持通配符匹配, 支持正则匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server_name  domain.com  www.domain.com;</span><br><span class="line">server_name  *.domain.com;</span><br><span class="line">server_name  domain.*;</span><br><span class="line">server_name  ~^(?.+)\.domain\.com$;</span><br></pre></td></tr></table></figure></p><p>很明显, 上面提到的无限子域名的网站, 是通过<code>*.domain.com</code>的方式实现的.<br><code>Nginx</code>配好后, 记得<code>hosts</code>文件也要改, 手头没有域名, 就只能改<code>hosts</code>了.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://blog.51cto.com/onlyzq/535279" target="_blank" rel="noopener">关于Nginx的server_name</a></li></ul>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Nginx_configures_multiple_server_name.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JSP的编译流程</title>
      <link>https://ahaochan.github.io/posts/JSP_compile_and_load.html</link>
      <guid>https://ahaochan.github.io/posts/JSP_compile_and_load.html</guid>
      <pubDate>Thu, 29 Nov 2018 10:05:15 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;情景还原&quot;&gt;&lt;a href=&quot;#情景还原&quot; class=&quot;headerlink&quot; title=&quot;情景还原&quot;&gt;&lt;/a&gt;情景还原&lt;/h1&gt;&lt;p&gt;用&lt;code&gt;Spring Boot&lt;/code&gt;简单搭建环境, 建一个&lt;code&gt;Controller&lt;/code&gt;以及两个&lt;code&gt;JSP&lt;/code&gt;页面。&lt;br&gt;发现&lt;code&gt;/test1&lt;/code&gt;页面&lt;code&gt;404&lt;/code&gt;不能访问, 而&lt;code&gt;/test2&lt;/code&gt;可以访问。&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Controller&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestController&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;test1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;test1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;/WEB-INF/views/IE10+.jsp&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@GetMapping&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;test2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;test2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;/WEB-INF/views/IE10.jsp&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="情景还原"><a href="#情景还原" class="headerlink" title="情景还原"></a>情景还原</h1><p>用<code>Spring Boot</code>简单搭建环境, 建一个<code>Controller</code>以及两个<code>JSP</code>页面。<br>发现<code>/test1</code>页面<code>404</code>不能访问, 而<code>/test2</code>可以访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"test1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/WEB-INF/views/IE10+.jsp"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"test2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/WEB-INF/views/IE10.jsp"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="问题所在"><a href="#问题所在" class="headerlink" title="问题所在"></a>问题所在</h1><p><code>JSP</code>是本质一个<code>Java</code>文件, 所以命名也需要遵循<code>Java</code>命名规则, <code>+</code>加号对<code>Java</code>命名规则来说是一个非法字符。<br>所以<code>IE10+.jsp</code>对应的<code>java</code>文件是不存在的, 自然也就<code>404</code>了。<br>我在<code>$CATALINA_BASE/work/Catalina/localhost/web/org/apache/jsp/WEB_002dINF/views/</code>下只看到了<code>IE10_jsp.java</code>和<code>IE10_jsp.class</code>这两个文件。</p><h1 id="JSP编译流程"><a href="#JSP编译流程" class="headerlink" title="JSP编译流程"></a>JSP编译流程</h1><ol><li>客户端请求<code>JSP</code>文件.</li><li><code>Servlet</code>容器将请求交给<code>org.apache.jasper.servlet.JspServlet</code>处理, 具体配置在<code>Tomcat</code>的<code>conf/web.xml</code>中.</li><li><code>JspServlet</code>生成<code>java</code>文件, 编译为<code>class</code>文件, 加载到<code>ClassLoader</code>, 加入缓存中.</li><li>调用生成的<code>Servlet</code>的<code>service</code>方法处理请求.</li></ol><h1 id="基于Tomcat-8-5-35的源码分析"><a href="#基于Tomcat-8-5-35的源码分析" class="headerlink" title="基于Tomcat 8.5.35的源码分析"></a>基于Tomcat 8.5.35的源码分析</h1><p><img src="http://yuml.me/diagram/nofunky/class/[&lt;&lt;PeriodicEventListener&gt;&gt;;interface]^-[JspServlet], [HttpServlet]^-[JspServlet]" alt="继承树"><br><code>JspServlet</code>继承了<code>HttpServlet</code>, 并实现了<code>PeriodicEventListener</code>接口, 这个接口暂时不管它, <code>HttpServlet</code>在我<a href="https://ahaochan.github.io/posts/HttpServlet_source_code.html">另一篇文章</a>中有做源码解析。</p><h2 id="重写了继承树上GenericServlet的方法"><a href="#重写了继承树上GenericServlet的方法" class="headerlink" title="重写了继承树上GenericServlet的方法"></a>重写了继承树上GenericServlet的方法</h2><p><code>JspServlet</code>重写了<code>GenericServlet</code>的两个方法.<br>默认情况下, 只做了一件事, 对<code>JspRuntimeContext</code>的实例进行初始化和销毁.</p><ol><li><code>public void init(ServletConfig config);</code> 初始化方法, 默认只初始化<code>JspRuntimeContext</code>的实例</li><li><code>public void destroy();</code> 销毁方法, 销毁<code>JspRuntimeContext</code>的实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.jasper.servlet.JspServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">PeriodicEventListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletContext context;</span><br><span class="line">    <span class="keyword">private</span> ServletConfig config;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Options options;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> JspRuntimeContext rctxt;</span><br><span class="line">    <span class="keyword">private</span> String jspFile;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(config);</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="keyword">this</span>.context = config.getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 省略部分代码, 默认不执行的代码</span></span><br><span class="line">        options = <span class="keyword">new</span> EmbeddedServletOptions(config, context);</span><br><span class="line">        rctxt = <span class="keyword">new</span> JspRuntimeContext(context, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        rctxt.destroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="重写了HttpServlet的service方法"><a href="#重写了HttpServlet的service方法" class="headerlink" title="重写了HttpServlet的service方法"></a>重写了HttpServlet的service方法</h2><p><code>service</code>方法是实际处理请求的逻辑方法。这里不对<code>include</code>等特殊情况做分析.<br>首先会判断请求参数是否携带<code>jsp_precompile</code>参数, 如果有的话就标记成预编译, 交给后面的核心代码使用.<br>然后再从缓存中获取<code>JspServletWrapper</code>实例, 没有则创建.<br>最后交给<code>JspServletWrapper</code>的<code>service</code>去执行核心代码.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.jasper.servlet.JspServlet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> <span class="keyword">implements</span> <span class="title">PeriodicEventListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ServletContext context;</span><br><span class="line">    <span class="keyword">private</span> ServletConfig config;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Options options;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> JspRuntimeContext rctxt;</span><br><span class="line">    <span class="keyword">private</span> String jspFile;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span> <span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// jspFile may be configured as an init-param for this servlet instance</span></span><br><span class="line">        String jspUri = request.getServletPath();</span><br><span class="line">        String pathInfo = request.getPathInfo();</span><br><span class="line">        <span class="keyword">if</span> (pathInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            jspUri += pathInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据 jsp_precompile 参数是否存在, 判断是否需要进行预编译</span></span><br><span class="line">        <span class="keyword">boolean</span> precompile = preCompile(request);</span><br><span class="line">        <span class="comment">// 处理请求</span></span><br><span class="line">        serviceJspFile(request, response, jspUri, precompile);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceJspFile</span><span class="params">(HttpServletRequest request, HttpServletResponse response, String jspUri, <span class="keyword">boolean</span> precompile)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 从 JspRuntimeContext 缓存中获取 JspServlet包装类, 双重锁避免高并发问题</span></span><br><span class="line">        JspServletWrapper wrapper = rctxt.getWrapper(jspUri);</span><br><span class="line">        <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                wrapper = rctxt.getWrapper(jspUri);</span><br><span class="line">                <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 判断请求的JSP是否存在, 避免创建无用的JspServletWwrapper</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == context.getResource(jspUri)) &#123;</span><br><span class="line">                        handleMissingResource(request, response, jspUri);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    wrapper = <span class="keyword">new</span> JspServletWrapper(config, options, jspUri, rctxt);</span><br><span class="line">                    <span class="comment">// 加入 JspRuntimeContext 缓存</span></span><br><span class="line">                    rctxt.addWrapper(jspUri,wrapper);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 2. 核心处理代码</span></span><br><span class="line">            wrapper.service(request, response, precompile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException fnfe) &#123;</span><br><span class="line">            handleMissingResource(request, response, jspUri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="生成Java文件并编译"><a href="#生成Java文件并编译" class="headerlink" title="生成Java文件并编译"></a>生成Java文件并编译</h2><p><code>options.getDevelopment()</code>这个变量是写在<code>web.xml</code>的<code>JspServlet</code>里, 通过<code>ServletConfig</code>的<code>getInitParameter(&quot;development&quot;)</code>方法获取. <code>web.xml</code>中没有进行配置, 所以默认为<code>true</code>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.jasper.servlet.JspServletWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspServletWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> JspCompilationContext ctxt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> mustCompile = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Options options;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="keyword">boolean</span> precompile)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException, FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">        <span class="comment">// (1) 编译, mustCompile默认为true, options.getDevelopment()默认为true</span></span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">        <span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (options.getDevelopment() || mustCompile) &#123;</span><br><span class="line">                    <span class="comment">// The following sets reload to true, if necessary</span></span><br><span class="line">                    ctxt.compile();</span><br><span class="line">                    mustCompile = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ==================省略部分代码==================</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>JspServletWrapper</code>的<code>service</code>调用了<code>JspCompilationContext</code>的<code>compile</code>方法.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.jasper.JspCompilationContext</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspCompilationContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compile</span><span class="params">()</span> <span class="keyword">throws</span> JasperException, FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取编译器</span></span><br><span class="line">        createCompiler();</span><br><span class="line">        <span class="comment">// 2. 判断是否需要重新将 JSP 转为 java 文件, 并编译为 class 文件</span></span><br><span class="line">        <span class="keyword">if</span> (jspCompiler.isOutDated()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isRemoved()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(jspUri);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 3. 先删除上次生成的 class 文件, 后删除 java 文件</span></span><br><span class="line">            jspCompiler.removeGeneratedFiles();</span><br><span class="line">            jspLoader = <span class="keyword">null</span>; <span class="comment">// 清空 ClassLoader, 为了进行 JSP 热部署</span></span><br><span class="line">            <span class="comment">// 4. 重新生成 java 文件, 后编译为 class 文件</span></span><br><span class="line">            jspCompiler.compile();</span><br><span class="line">            jsw.setReload(<span class="keyword">true</span>); <span class="comment">// 设置重新加载 Servlet 的标识</span></span><br><span class="line">            jsw.setCompilationException(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略部分捕获异常的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一步, <code>createCompiler();</code>先获取编译器</p><ol><li>判断<code>web.xml</code>里的<code>JspServlet</code>有没有定义编译器的类名<code>compilerClassName</code>, 有则创建</li><li>判断<code>web.xml</code>里的<code>JspServlet</code>有没有定义<code>compiler</code>, 有则先创建<code>JDTCompiler</code>编译器, 否则先创建<code>AntCompiler</code>. 创建失败则尝试创建两者的另一个编译器.</li><li>都创建失败, 则抛出异常</li></ol><p>第二步, <code>jspCompiler.isOutDated()</code>比较<code>JSP</code>的最后修改时间和对应的<code>class</code>文件<br>最后修改时间, 过时则重新编译.  可以在<code>web.xml</code>里的<code>JspServlet</code>配置<code>modificationTestInterval</code>参数, 指定一定秒数内<code>return false</code>, 不进行重新编译.</p><p>第三步, 先删除上次生成的<code>class</code>文件, 后删除<code>java</code>文件。<br>第四步, 调用之前获取到的编译器的<code>compile</code>方法生成<code>java</code>文件, 并编译为<code>class</code>文件.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.jasper.compiler.Compiler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Compiler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compile</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, JasperException, Exception </span>&#123;</span><br><span class="line">        compile(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compile</span><span class="params">(<span class="keyword">boolean</span> compileClass)</span> <span class="keyword">throws</span> FileNotFoundException, JasperException, Exception </span>&#123;</span><br><span class="line">        compile(compileClass, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compile</span><span class="params">(<span class="keyword">boolean</span> compileClass, <span class="keyword">boolean</span> jspcMode)</span> <span class="keyword">throws</span> FileNotFoundException, JasperException, Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 生成 java 文件</span></span><br><span class="line">        String[] smap = generateJava();</span><br><span class="line">        File javaFile = <span class="keyword">new</span> File(ctxt.getServletJavaFileName());</span><br><span class="line">        Long jspLastModified = ctxt.getLastModified(ctxt.getJspFile());</span><br><span class="line">        javaFile.setLastModified(jspLastModified.longValue());</span><br><span class="line">        <span class="keyword">if</span> (compileClass) &#123;</span><br><span class="line">            <span class="comment">// 2. 编译为 class 文件, 交给子类实现, 如 AntCompiler、JDTCompiler</span></span><br><span class="line">            generateClass(smap);</span><br><span class="line">            <span class="comment">// Fix for bugzilla 41606</span></span><br><span class="line">            <span class="comment">// Set JspServletWrapper.servletClassLastModifiedTime after successful compile</span></span><br><span class="line">            File targetFile = <span class="keyword">new</span> File(ctxt.getClassFileName());</span><br><span class="line">            <span class="keyword">if</span> (targetFile.exists()) &#123;</span><br><span class="line">                targetFile.setLastModified(jspLastModified.longValue());</span><br><span class="line">                <span class="keyword">if</span> (jsw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    jsw.setServletClassLastModifiedTime(</span><br><span class="line">                            jspLastModified.longValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="获取-Servlet"><a href="#获取-Servlet" class="headerlink" title="获取 Servlet"></a>获取 Servlet</h2><p>同样是<code>JspServletWrapper</code>的<code>service</code>方法, 在编译出了<code>class</code>文件后, 就应该要将<code>class</code>加载到<code>ClassLoader</code>里了。<br>在之前提到的<code>JspCompilationContext</code>的<code>compile</code>方法里, 将<code>JSP</code>的<code>ClassLoader</code>变量<code>jspLoader</code>设置为了<code>null</code>. 因为一个<code>ClassLoader</code>不能加载两个相同的类, 所以要一个新的<code>ClassLoader</code>进行热部署<code>JSP</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.jasper.servlet.JspServletWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspServletWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Servlet theServlet;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="keyword">boolean</span> precompile)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException, FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">        <span class="comment">// (2) (重新)加载 servlet class 文件</span></span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">        Servlet servlet = getServlet();</span><br><span class="line">        <span class="comment">// 如果请求参数 jsp_precompile 存在, 则不执行之后的代码</span></span><br><span class="line">        <span class="keyword">if</span> (precompile) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Servlet <span class="title">getServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getReloadInternal() || theServlet == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// Synchronizing on jsw enables simultaneous loading</span></span><br><span class="line">                <span class="comment">// of different pages, but not the same page.</span></span><br><span class="line">                <span class="keyword">if</span> (getReloadInternal() || theServlet == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 1. 先销毁旧的 Servlet</span></span><br><span class="line">                    destroy();</span><br><span class="line">                    <span class="comment">// 2. 加载 class 并反射创建 Servlet, 这里的 JspLoader 在之前设置为 null, 所以这里会 new 一个 JspLoader</span></span><br><span class="line">                    InstanceManager instanceManager = InstanceManagerFactory.getInstanceManager(config);</span><br><span class="line">                    <span class="comment">// fqcn 是  Full Qualified Class Name 的缩写</span></span><br><span class="line">                    Servlet servlet = (Servlet) instanceManager.newInstance(ctxt.getFQCN(), ctxt.getJspLoader());</span><br><span class="line">                    <span class="comment">// 3. 初始化 Servlet</span></span><br><span class="line">                    servlet.init(config);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 4. JSP 重载数量+1</span></span><br><span class="line">                    <span class="keyword">if</span> (theServlet != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ctxt.getRuntimeContext().incrementJspReloadCount();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    theServlet = servlet;</span><br><span class="line">                    reload = <span class="keyword">false</span>; <span class="comment">// 编译时会重新设置为 true, 用于进入此 if</span></span><br><span class="line">                    <span class="comment">// Volatile 'reload' forces in order write of 'theServlet' and new servlet object</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> theServlet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="限制-JSP-加载数量-选读"><a href="#限制-JSP-加载数量-选读" class="headerlink" title="限制 JSP 加载数量(选读)"></a>限制 JSP 加载数量(选读)</h2><p>默认不执行这段代码, 属于程序优化部分, 比较简单, 就是对一个队列进行先进先出的操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.jasper.servlet.JspServletWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspServletWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unloadAllowed; <span class="comment">// web.xml 的 JspServlet 的 maxLoadedJsps  参数配置, 大于0则为true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unloadByIdle;  <span class="comment">// web.xml 的 JspServlet 的 jspIdleTimeout 参数配置, 大于0则为true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unloadByCount; <span class="comment">// 值为 unloadAllowed || unloadByIdle</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="keyword">boolean</span> precompile)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException, FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">        <span class="comment">// (3) 限制 JSP 数量, 先进先出的队列</span></span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">        <span class="keyword">if</span> (unloadAllowed) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (unloadByCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (unloadHandle == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        unloadHandle = ctxt.getRuntimeContext().push(<span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastUsageTime &lt; ctxt.getRuntimeContext().getLastJspQueueUpdate()) &#123;</span><br><span class="line">                        <span class="comment">// 核心代码, 移除队列中的 JSP 缓存</span></span><br><span class="line">                        ctxt.getRuntimeContext().makeYoungest(unloadHandle);</span><br><span class="line">                        lastUsageTime = System.currentTimeMillis();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lastUsageTime &lt; ctxt.getRuntimeContext().getLastJspQueueUpdate()) &#123;</span><br><span class="line">                        lastUsageTime = System.currentTimeMillis();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="JSP-生成的-Servlet-进行处理请求"><a href="#JSP-生成的-Servlet-进行处理请求" class="headerlink" title="JSP 生成的 Servlet 进行处理请求"></a>JSP 生成的 Servlet 进行处理请求</h2><p>终于到了我们熟悉的环节, 调用创建的<code>Servlet</code>的<code>service</code>方法, 处理请求.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.jasper.servlet.JspServletWrapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JspServletWrapper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unloadAllowed; <span class="comment">// web.xml 的 JspServlet 的 maxLoadedJsps  参数配置, 大于0则为true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unloadByIdle;  <span class="comment">// web.xml 的 JspServlet 的 jspIdleTimeout 参数配置, 大于0则为true</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> unloadByCount; <span class="comment">// 值为 unloadAllowed || unloadByIdle</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response, <span class="keyword">boolean</span> precompile)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException, FileNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">        <span class="comment">// (4) 执行创建的 Servlet 的 service 方法</span></span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">        <span class="keyword">if</span> (servlet <span class="keyword">instanceof</span> SingleThreadModel) &#123;</span><br><span class="line">            <span class="comment">// sync on the wrapper so that the freshness</span></span><br><span class="line">            <span class="comment">// of the page is determined right before servicing</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                servlet.service(request, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// =========================================</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="一个简单的Hello-world"><a href="#一个简单的Hello-world" class="headerlink" title="一个简单的Hello world"></a>一个简单的Hello world</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        Hello world</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.jsp.WEB_002dINF.views.upload;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.jsp.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IE10_jsp</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">HttpJspBase</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceDependent</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">org</span>.<span class="title">apache</span>.<span class="title">jasper</span>.<span class="title">runtime</span>.<span class="title">JspSourceImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> javax.servlet.jsp.JspFactory _jspxFactory =</span><br><span class="line">          javax.servlet.jsp.JspFactory.getDefaultFactory();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> java.util.Map&lt;java.lang.String,java.lang.Long&gt; _jspx_dependants;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.Set&lt;java.lang.String&gt; _jspx_imports_packages;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.util.Set&lt;java.lang.String&gt; _jspx_imports_classes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    _jspx_imports_packages = <span class="keyword">new</span> java.util.HashSet&lt;&gt;();</span><br><span class="line">    _jspx_imports_packages.add(<span class="string">"javax.servlet"</span>);</span><br><span class="line">    _jspx_imports_packages.add(<span class="string">"javax.servlet.http"</span>);</span><br><span class="line">    _jspx_imports_packages.add(<span class="string">"javax.servlet.jsp"</span>);</span><br><span class="line">    _jspx_imports_classes = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> javax.el.ExpressionFactory _el_expressionfactory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> org.apache.tomcat.InstanceManager _jsp_instancemanager;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Map&lt;java.lang.String,java.lang.Long&gt; getDependants() &#123;</span><br><span class="line">    <span class="keyword">return</span> _jspx_dependants;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Set&lt;java.lang.String&gt; getPackageImports() &#123;</span><br><span class="line">    <span class="keyword">return</span> _jspx_imports_packages;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.Set&lt;java.lang.String&gt; getClassImports() &#123;</span><br><span class="line">    <span class="keyword">return</span> _jspx_imports_classes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> javax.el.<span class="function">ExpressionFactory <span class="title">_jsp_getExpressionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_el_expressionfactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_el_expressionfactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">          _el_expressionfactory = _jspxFactory.getJspApplicationContext(getServletConfig().getServletContext()).getExpressionFactory();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _el_expressionfactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> org.apache.tomcat.<span class="function">InstanceManager <span class="title">_jsp_getInstanceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_jsp_instancemanager == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_jsp_instancemanager == <span class="keyword">null</span>) &#123;</span><br><span class="line">          _jsp_instancemanager = org.apache.jasper.runtime.InstanceManagerFactory.getInstanceManager(getServletConfig());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _jsp_instancemanager;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> java.lang.String _jspx_method = request.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">"GET"</span>.equals(_jspx_method) &amp;&amp; !<span class="string">"POST"</span>.equals(_jspx_method) &amp;&amp; !<span class="string">"HEAD"</span>.equals(_jspx_method) &amp;&amp; !javax.servlet.DispatcherType.ERROR.equals(request.getDispatcherType())) &#123;</span><br><span class="line">      response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, <span class="string">"JSPs only permit GET POST or HEAD"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;</span><br><span class="line">    javax.servlet.http.HttpSession session = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletContext application;</span><br><span class="line">    <span class="keyword">final</span> javax.servlet.ServletConfig config;</span><br><span class="line">    javax.servlet.jsp.JspWriter out = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> java.lang.Object page = <span class="keyword">this</span>;</span><br><span class="line">    javax.servlet.jsp.JspWriter _jspx_out = <span class="keyword">null</span>;</span><br><span class="line">    javax.servlet.jsp.PageContext _jspx_page_context = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">      pageContext = _jspxFactory.getPageContext(<span class="keyword">this</span>, request, response,</span><br><span class="line">      <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">8192</span>, <span class="keyword">true</span>);</span><br><span class="line">      _jspx_page_context = pageContext;</span><br><span class="line">      application = pageContext.getServletContext();</span><br><span class="line">      config = pageContext.getServletConfig();</span><br><span class="line">      session = pageContext.getSession();</span><br><span class="line">      out = pageContext.getOut();</span><br><span class="line">      _jspx_out = out;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// =========================== 输出代码 =====================================</span></span><br><span class="line">      out.write(<span class="string">"\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;html&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;body&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"Hello world\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;/body&gt;\r\n"</span>);</span><br><span class="line">      out.write(<span class="string">"&lt;/html&gt;\r\n"</span>);</span><br><span class="line">      <span class="comment">// =========================== 输出代码 =====================================</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (java.lang.Throwable t) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(t <span class="keyword">instanceof</span> javax.servlet.jsp.SkipPageException))&#123;</span><br><span class="line">        out = _jspx_out;</span><br><span class="line">        <span class="keyword">if</span> (out != <span class="keyword">null</span> &amp;&amp; out.getBufferSize() != <span class="number">0</span>)</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (response.isCommitted()) &#123;</span><br><span class="line">              out.flush();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              out.clearBuffer();</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (java.io.IOException e) &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (_jspx_page_context != <span class="keyword">null</span>) _jspx_page_context.handlePageException(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      _jspxFactory.releasePageContext(_jspx_page_context);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://shenzhang.github.io/blog/2013/06/26/recompile-and-redeploy-in-jsp/" target="_blank" rel="noopener">Jsp的编译过程和热部署原理</a></li><li><a href="https://www.jianshu.com/p/01805c2a1036" target="_blank" rel="noopener">JSP 热部署 源码解析</a></li><li><a href="https://blog.csdn.net/hwcptbtptp/article/details/78270243" target="_blank" rel="noopener">FQCN是什么鬼</a></li><li><a href="https://stackoverflow.com/questions/53511441" target="_blank" rel="noopener">Why Spring Boot cannot parse view with + symbol?</a></li></ul>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/JSP_compile_and_load.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux的资源限制ulimit命令</title>
      <link>https://ahaochan.github.io/posts/ulimit_Command_of_Linux.html</link>
      <guid>https://ahaochan.github.io/posts/ulimit_Command_of_Linux.html</guid>
      <pubDate>Thu, 08 Nov 2018 07:32:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ulimit&lt;/code&gt;是一个&lt;code&gt;Linux&lt;/code&gt;命令, 用于限制&lt;code&gt;shell&lt;/code&gt;进程及其子进程的系统资源使用。通俗且不严谨的讲，就是限制登录用户能一次性打开多少个进程，多少个文件等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假设有这样一种情况，当一台 Linux 主机上同时登陆了 10 个人，在系统资源无限制的情况下，这 10 个用户同时打开了 500 个文档，而假设每个文档的大小有 10M，这时系统的内存资源就会受到巨大的挑战。&lt;/p&gt;
&lt;/blockquote&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>ulimit</code>是一个<code>Linux</code>命令, 用于限制<code>shell</code>进程及其子进程的系统资源使用。通俗且不严谨的讲，就是限制登录用户能一次性打开多少个进程，多少个文件等等。</p><blockquote><p>假设有这样一种情况，当一台 Linux 主机上同时登陆了 10 个人，在系统资源无限制的情况下，这 10 个用户同时打开了 500 个文档，而假设每个文档的大小有 10M，这时系统的内存资源就会受到巨大的挑战。</p></blockquote><a id="more"></a><h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><p><code>ulimit</code>限制分为<code>soft</code>软上限和<code>hard</code>硬上限, 使用<code>ulimit</code>命令默认修改<code>soft</code>软上限。</p><ul><li><code>soft</code>软上限: 任何进程都可以修改软上限，但是软上限不能超过硬上限</li><li><code>hard</code>硬上限: 普通进程可以降低硬上限，只有<code>root</code>可以提高硬上限</li></ul><p>命令格式: <code>ulimit [options] [limit]</code></p><table><thead><tr><th style="text-align:center"><code>options</code>参数</th><th style="text-align:center">含义</th><th style="text-align:center">例子</th></tr></thead><tbody><tr><td style="text-align:center"><code>-H</code></td><td style="text-align:center">设置硬资源限制, 一旦设置不能增加。</td><td style="text-align:center"><code>ulimit -Hs 64</code> 限制硬资源, 线程栈大小为 64K。</td></tr><tr><td style="text-align:center"><code>-S</code></td><td style="text-align:center">设置软资源限制, 设置后可以增加, 但是不能超过硬资源设置。</td><td style="text-align:center"><code>ulimit -Sn 32</code> 限制软资源, 32 个文件描述符。</td></tr><tr><td style="text-align:center"><code>-a</code></td><td style="text-align:center">显示当前所有的 limit 信息, 默认显示软上限。</td><td style="text-align:center"><code>ulimit -a</code> 显示当前所有的 limit 信息。</td></tr><tr><td style="text-align:center"><code>-c</code></td><td style="text-align:center">最大的 core 文件的大小, 以 blocks 为单位。</td><td style="text-align:center"><code>ulimit -c unlimited</code>  对生成的 core 文件的大小不进行限制。</td></tr><tr><td style="text-align:center"><code>-d</code></td><td style="text-align:center">进程最大的数据段的大小, 以 Kbytes 为单位。</td><td style="text-align:center"><code>ulimit -d unlimited</code> 对进程的数据段大小不进行限制。</td></tr><tr><td style="text-align:center"><code>-f</code></td><td style="text-align:center">进程可以创建文件的最大值, 以 blocks 为单位。</td><td style="text-align:center"><code>ulimit -f 2048</code> 限制进程可以创建的最大文件大小为 2048 blocks。</td></tr><tr><td style="text-align:center"><code>-l</code></td><td style="text-align:center">最大可加锁内存大小, 以 Kbytes 为单位。</td><td style="text-align:center"><code>ulimit -l 32</code> 限制最大可加锁内存大小为 32 Kbytes。</td></tr><tr><td style="text-align:center"><code>-m</code></td><td style="text-align:center">最大内存大小, 以 Kbytes 为单位。</td><td style="text-align:center"><code>ulimit -m unlimited</code> 对最大内存不进行限制。</td></tr><tr><td style="text-align:center"><code>-n</code></td><td style="text-align:center">可以打开最大文件描述符的数量。</td><td style="text-align:center"><code>ulimit -n 128</code> 限制最大可以使用 128 个文件描述符。</td></tr><tr><td style="text-align:center"><code>-p</code></td><td style="text-align:center">管道缓冲区的大小, 以 Kbytes 为单位。</td><td style="text-align:center"><code>ulimit -p 512</code> 限制管道缓冲区的大小为 512 Kbytes。</td></tr><tr><td style="text-align:center"><code>-s</code></td><td style="text-align:center">线程栈大小, 以 Kbytes 为单位。</td><td style="text-align:center"><code>ulimit -s 512</code> 限制线程栈的大小为 512 Kbytes。</td></tr><tr><td style="text-align:center"><code>-t</code></td><td style="text-align:center">最大的 CPU 占用时间, 以秒为单位。</td><td style="text-align:center"><code>ulimit -t unlimited</code> 对最大的 CPU 占用时间不进行限制。</td></tr><tr><td style="text-align:center"><code>-u</code></td><td style="text-align:center">用户最大可用的进程数。</td><td style="text-align:center"><code>ulimit -u 64</code> 限制用户最多可以使用 64 个进程。</td></tr><tr><td style="text-align:center"><code>-v</code></td><td style="text-align:center">进程最大可用的虚拟内存, 以 Kbytes 为单位。</td><td style="text-align:center"><code>ulimit -v 200000</code> 限制最大可用的虚拟内存为 200000 Kbytes。</td></tr></tbody></table><h1 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h1><p><strong>对登录用户进行限制</strong></p><ol><li>在<code>/etc/profile</code>、<code>/etc/bashrc</code>、<code>~/.bash_profile</code>、<code>~/.bashrc</code>文件中写入<code>ulimit</code>命令。</li><li>直接在控制台输入<code>ulimit</code>命令, 这是临时配置, 重启失效。</li></ol><p><strong>对应用程序进行限制</strong></p><ol><li>对<code>Tomcat</code>进行限制, 编写启动脚本<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -s 512;</span><br><span class="line">startup.sh</span><br></pre></td></tr></table></figure></li></ol><p><strong>对多个用户或用户组进行限制</strong></p><ol><li>在<code>/etc/security/limits.conf</code>中输入<code>&lt;domain&gt; &lt;type&gt; &lt;item&gt; &lt;value&gt;</code>, 每一行一个限制。<blockquote><p>domain 表示用户或者组的名字，还可以使用 * 作为通配符。Type 可以有两个值，soft 和 hard。Item 则表示需要限定的资源，可以有很多候选值，如 stack，cpu，nofile 等等，分别表示最大的堆栈大小，占用的 cpu 时间，以及打开的文件数。通过添加对应的一行描述，则可以产生相应的限制</p></blockquote></li></ol><p><strong>对系统全局的进程进行限制</strong></p><ol><li>修改<code>/proc</code>下的文件</li></ol><h1 id="常用例子"><a href="#常用例子" class="headerlink" title="常用例子"></a>常用例子</h1><ol><li><code>ulimit -a</code>: 查看当前 <code>shell</code> 的所有资源限制，默认显示软限制</li><li><code>ulimit -Sa</code>: 查看当前 <code>shell</code> 的所有资源限制，<code>-S</code> 表示显示软限制</li><li><code>ulimit -Ha</code>: 查看当前 <code>shell</code> 的所有资源限制，<code>-H</code> 表示显示硬限制</li><li><code>ulimit -n</code>: 显示当前可打开的文件描述符数量，软限制</li><li><code>ulimit -Hn</code>: 显示当前可打开的文件描述符数量，硬限制</li><li><code>ulimit -n 10240</code>: 修改可打开的文件描述符数为 <code>10240</code>，默认软限制，除非指明参数 <code>H</code></li><li><code>ulimit -Hn 51200</code>: 修改可打开的文件描述符数为 <code>51200</code>，硬限制(如果是提高硬限制，则需要 <code>root</code> 权限)</li><li><code>ulimit -s 102400</code>: 修改堆栈大小的软限制为 <code>102400 kbytes</code> 即 <code>100 MB</code></li><li><code>ulimit -Hs unlimited</code>: 修改堆栈大小的硬限制为 <code>unlimited</code>，即不限制上限</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ulimit/index.html" target="_blank" rel="noopener">通过 ulimit 改善系统性能</a></li><li><a href="https://www.zfl9.com/ulimit.html" target="_blank" rel="noopener">Linux ulimit详解</a></li></ul>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/ulimit_Command_of_Linux.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>数据库查询出的数据转为树形结构</title>
      <link>https://ahaochan.github.io/posts/The_database_records_converted_to_tree_structure..html</link>
      <guid>https://ahaochan.github.io/posts/The_database_records_converted_to_tree_structure..html</guid>
      <pubDate>Thu, 01 Nov 2018 01:57:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;数据准备&quot;&gt;&lt;a href=&quot;#数据准备&quot; class=&quot;headerlink&quot; title=&quot;数据准备&quot;&gt;&lt;/a&gt;数据准备&lt;/h1&gt;&lt;p&gt;假设有以下数据, 要建立树形结构&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;id    pid    name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6      5     node6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5      2     node5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4      2     node4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3      1     node3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2      0     node2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1      0     node1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h1><p>假设有以下数据, 要建立树形结构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">id    pid    name</span><br><span class="line">6      5     node6</span><br><span class="line">5      2     node5</span><br><span class="line">4      2     node4</span><br><span class="line">3      1     node3</span><br><span class="line">2      0     node2</span><br><span class="line">1      0     node1</span><br></pre></td></tr></table></figure></p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer pid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    List&lt;TreeNode&gt; subTree;</span><br><span class="line">    <span class="comment">// 省略 getter 和 setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库查出的都是<code>List</code>集合, 要转成树形结构只能用<code>Java</code>代码实现。<br>转化的方式有两种</p><ol><li>先查询出根节点, 再用<code>pid</code>递归查询数据库</li><li>一次性查出所有的记录, 然后用<code>Java</code>代码组装树形结构</li></ol><h1 id="递归查询数据库-不推荐-耗时长"><a href="#递归查询数据库-不推荐-耗时长" class="headerlink" title="递归查询数据库(不推荐, 耗时长)"></a>递归查询数据库(不推荐, 耗时长)</h1><p>这种方法编写方便, 但是要进行频繁的数据库<code>IO</code>, 所以不推荐使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface DAO &#123;</span><br><span class="line">    List&lt;TreeNode&gt; getByPid(int pid);</span><br><span class="line">&#125;</span><br><span class="line">public class TestService &#123;</span><br><span class="line">    private DAO dao = new DAO();</span><br><span class="line">    public List&lt;TreeNode&gt; getTree() &#123;</span><br><span class="line">        return getTree(0);</span><br><span class="line">    &#125;</span><br><span class="line">    private List&lt;TreeNode&gt; getTree(int pid) &#123;</span><br><span class="line">        List&lt;TreeNode&gt; parent = dao.getByPid(pid);</span><br><span class="line">        for(TreeNode item : parent) &#123;</span><br><span class="line">            List&lt;TreeNode&gt; child = dao.getByPid(item.getId());</span><br><span class="line">            item.setSubTree(child);</span><br><span class="line">        &#125;</span><br><span class="line">        return parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果有<code>n</code>个节点, 那么就要查询<code>n</code>次数据库, 数量大了就会特别慢。</p><h1 id="一次性查询出所有记录"><a href="#一次性查询出所有记录" class="headerlink" title="一次性查询出所有记录"></a>一次性查询出所有记录</h1><p>既然数据库查询耗时长, 那么先一次性把所有数据查到内存中, 再自由组装树形结构。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer pid;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    List&lt;TreeNode&gt; subTree;</span><br><span class="line">    <span class="comment">// 省略 getter 和 setter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">source</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> TreeNode(<span class="number">6</span>, <span class="number">5</span>, <span class="string">"node6"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> TreeNode(<span class="number">5</span>, <span class="number">2</span>, <span class="string">"node5"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> TreeNode(<span class="number">4</span>, <span class="number">2</span>, <span class="string">"node4"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> TreeNode(<span class="number">3</span>, <span class="number">1</span>, <span class="string">"node3"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> TreeNode(<span class="number">2</span>, <span class="number">0</span>, <span class="string">"node2"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> TreeNode(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"node1"</span>));</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里在内存中组装树形结构也有两种方法, 递归和循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; recursive = recursive(TreeNode.source());</span><br><span class="line">        List&lt;TreeNode&gt; loop = loop(TreeNode.source());</span><br><span class="line">        System.out.println(JSONObject.toJSONString(recursive));</span><br><span class="line">        System.out.println(JSONObject.toJSONString(loop));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================= 循环构建 ======================</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">loop</span><span class="params">(List&lt;TreeNode&gt; source)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; topNodes = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (TreeNode node : source) &#123;</span><br><span class="line">            <span class="comment">// 1. 获取 top 节点, 即没有 parent 节点的节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.getPid() == <span class="number">0</span>) &#123;</span><br><span class="line">                topNodes.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 寻找 是否有节点的 parent 节点 为当前节点, 有则加入</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode find : source) &#123;</span><br><span class="line">                <span class="keyword">if</span> (find.getPid().equals(node.getId())) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (node.getSubTree() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        node.setSubTree(<span class="keyword">new</span> ArrayList&lt;TreeNode&gt;());</span><br><span class="line">                    &#125;</span><br><span class="line">                    node.getSubTree().add(find);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> topNodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================= 递归构建 ======================</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;TreeNode&gt; <span class="title">recursive</span><span class="params">(List&lt;TreeNode&gt; source)</span> </span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; trees = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (TreeNode node : source) &#123;</span><br><span class="line">            <span class="comment">// 1. 获取 top 节点, 即没有 parent 节点的节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.getPid() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 2. 寻找 是否有节点的 parent 节点 为当前节点, 有则加入</span></span><br><span class="line">                trees.add(find(node, source));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title">find</span><span class="params">(TreeNode parent, List&lt;TreeNode&gt; treeNodes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode it : treeNodes) &#123;</span><br><span class="line">            <span class="keyword">if</span>(parent.getId().equals(it.getPid())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent.getSubTree() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    parent.setSubTree(<span class="keyword">new</span> ArrayList&lt;TreeNode&gt;());</span><br><span class="line">                &#125;</span><br><span class="line">                parent.getSubTree().add(find(it,treeNodes));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>某篇CSDN博客, 后来找不到了</p>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/The_database_records_converted_to_tree_structure..html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用SLF4J在多线程下输出到不同的日志文件</title>
      <link>https://ahaochan.github.io/posts/Use_SLF4J_to_output_to_different_log_files_under_multi_threading.html</link>
      <guid>https://ahaochan.github.io/posts/Use_SLF4J_to_output_to_different_log_files_under_multi_threading.html</guid>
      <pubDate>Tue, 16 Oct 2018 12:06:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近做了个数据传输的模块, 用到了线程池多线程, 要求将市平台的文章导入到公司的项目中进行管理, 每个栏目都有对应的文章, 但是打印日志时出现了日志混乱的问题。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;栏目A传输文章1: 开始&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;栏目B传输文章2: 开始&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;栏目B传输文章2: 成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;栏目C传输文章3: 开始&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;栏目A传输文章1: 成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;栏目C传输文章3: 失败&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近做了个数据传输的模块, 用到了线程池多线程, 要求将市平台的文章导入到公司的项目中进行管理, 每个栏目都有对应的文章, 但是打印日志时出现了日志混乱的问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">栏目A传输文章1: 开始</span><br><span class="line">栏目B传输文章2: 开始</span><br><span class="line">栏目B传输文章2: 成功</span><br><span class="line">栏目C传输文章3: 开始</span><br><span class="line">栏目A传输文章1: 成功</span><br><span class="line">栏目C传输文章3: 失败</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>每个线程输出到不同的日志文件下, 这个功能应该是可以做到的, 只要在初始化<code>Logger</code>时指定对应的文件名就可以了。</p><h1 id="Logback-的实现-版本号1-1-11"><a href="#Logback-的实现-版本号1-1-11" class="headerlink" title="Logback 的实现(版本号1.1.11)"></a>Logback 的实现(版本号1.1.11)</h1><p>除了<code>Logback</code>的基础模块, 需要追加引用<a href="https://mvnrepository.com/artifact/ch.qos.logback/logback-access" target="_blank" rel="noopener"><code>logback-access</code></a>模块。</p><p><code>slf4j</code>提供了<code>Mapped Diagnostic Context (MDC)</code>这个工具, 来设置自定义变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MDC.put(<span class="string">"logName"</span>, <span class="string">"LogFile1"</span>);</span><br><span class="line">logger.debug(<span class="string">"Test"</span> + System.currentTimeMillis());</span><br><span class="line">MDC.remove(<span class="string">"logName"</span>);</span><br></pre></td></tr></table></figure></p><p>在代码中这样使用, 即可在配置文件中取到<code>value</code>。<br><code>Logback</code>提供了<code>SiftingAppender</code>来进行日志记录, 并且可以读取<code>MDC</code>的值到日志路径的变量中。<br>下面代码是从我之前写的<code>Logback</code>日志配置中复制并加以微调的。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 MDC 的 appender --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE_CUSTOM"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.sift.SiftingAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- discriminator 的默认实现类 ch.qos.logback.classic.sift.MDCBasedDiscriminator --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>logName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>MyFile<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sift</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 标准的文件输出 Appender, 文件名根据 MDC 动态生成  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE-$&#123;logName&#125;"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span>自定义文件路径/$&#123;logName&#125;.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 最常用的滚动策略，它根据时间来制定滚动策略.既负责滚动也负责出发滚动 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--日志输出位置  可相对、和绝对路径 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>自定义文件路径/%d&#123;yyyy-MM-dd&#125;/$&#123;logName&#125;.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sift</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- root级别 INFO --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件输出 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE_CUSTOM"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="log4j的实现-版本号1-2-16"><a href="#log4j的实现-版本号1-2-16" class="headerlink" title="log4j的实现(版本号1.2.16)"></a>log4j的实现(版本号1.2.16)</h1><p><code>log4j</code>没有<code>SiftingAppender</code>, 并且也不能读取<code>MDC</code>到日志路径的变量中(但是可以读取到日志格式中)。</p><p>用编程的方式为每个对象示例初始化<code>Logger</code>, 然后为其添加<code>Appender</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> org.apache.log4j.<span class="function">Logger <span class="title">getLogger</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        org.apache.log4j.Logger logger = org.apache.log4j.Logger.getLogger(<span class="string">"日志"</span>+id);</span><br><span class="line">        logger.setLevel(Level.DEBUG);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意要判断是否已存在Appender, 否则会重复创建</span></span><br><span class="line">        String appenderName = <span class="string">"log"</span>+id+<span class="string">"Appender"</span>;</span><br><span class="line">        <span class="keyword">if</span>(logger.getAppender(appenderName) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RollingFileAppender appender = <span class="keyword">new</span> RollingFileAppender();</span><br><span class="line">            appender.setName(appenderName);</span><br><span class="line">            appender.setFile(<span class="string">"D:\\mylog\\"</span>+id+<span class="string">".log"</span>);</span><br><span class="line">            appender.setLayout(<span class="keyword">new</span> PatternLayout(<span class="string">"[S][%d&#123;yyyyMMdd HH:mm:ss&#125;][%-5p][%C:%L] - %m%n"</span>));</span><br><span class="line">            appender.setMaxFileSize(<span class="string">"10240KB"</span>);</span><br><span class="line">            appender.setMaxBackupIndex(<span class="number">10</span>);</span><br><span class="line">            appender.activateOptions();</span><br><span class="line">            logger.addAppender(appender);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.mkyong.com/logging/logback-different-log-file-for-each-thread" target="_blank" rel="noopener">logback-different-log-file-for-each-thread</a></li></ul>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Use_SLF4J_to_output_to_different_log_files_under_multi_threading.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx的负载均衡配置</title>
      <link>https://ahaochan.github.io/posts/Nginx_Server_load_balancing_configuration.html</link>
      <guid>https://ahaochan.github.io/posts/Nginx_Server_load_balancing_configuration.html</guid>
      <pubDate>Sun, 16 Sep 2018 10:36:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;负载均衡本质就是一个反向代理。&lt;br&gt;通俗点讲, 就类似&lt;code&gt;10086&lt;/code&gt;客服电话, 如果只有一个通话员, 那全国十几亿人肯定处理不过来, 这时候就多招聘一堆通话员, 做负载均衡, 这样就减少了通话员的压力。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>负载均衡本质就是一个反向代理。<br>通俗点讲, 就类似<code>10086</code>客服电话, 如果只有一个通话员, 那全国十几亿人肯定处理不过来, 这时候就多招聘一堆通话员, 做负载均衡, 这样就减少了通话员的压力。</p><a id="more"></a><h1 id="SLB和GSLB"><a href="#SLB和GSLB" class="headerlink" title="SLB和GSLB"></a>SLB和GSLB</h1><p>负载均衡又分为</p><ol><li><code>GSLB(Global Server Load Balance)</code>全局负载均衡</li><li><code>SLB(Server load balancing)</code>负载均衡</li></ol><p>还是以<code>10086</code>为例, 如果只有北京开设了一个通话员中心(<code>SLB</code>), 即使通话员(<code>server</code>)的数量足够, 但是广东省的要打电话过去, 西藏的要打电话过去, 路途遥远。那么就设立多个通话员中心(<code>SLB</code>), 广东省的打广东省的<code>10086</code>, 西藏的打西藏的<code>10086</code>, 如果解决不了问题, 再上升到北京的<code>10086</code>。<br><img src="https://yuml.me/diagram/nofunky/class/[1广东用户]-&gt;[1广东10086],[2西藏用户]-&gt;[2西藏10086],[1广东10086]-&gt;[3北京10086],[2西藏10086]-&gt;[3北京10086]" alt=""><br>也就是说, 多个<code>SLB</code>组成了<code>GSLB</code>。</p><h1 id="OSI模型上的负载均衡"><a href="#OSI模型上的负载均衡" class="headerlink" title="OSI模型上的负载均衡"></a>OSI模型上的负载均衡</h1><p>学过计算机网络的应该都知道<a href="https://zh.wikipedia.org/wiki/OSI模型" target="_blank" rel="noopener"><code>OSI</code>模型</a>, 分为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。<br>比如数据链路层是根据<code>mac</code>地址进行数据包发送的, 那么就可以在这里做负载均衡。（一般是用虚拟<code>mac</code>地址方式，外部对虚拟<code>mac</code>地址请求，负载均衡接收后分配后端实际的<code>mac</code>地址响应）。</p><p>最常用的就是<br><strong>四层负载均衡(<code>IP + port</code>)</strong><br><strong>七层负载均衡(<code>IP + port + URL</code>)</strong><br><code>Nginx</code>是应用层, 也就是七层负载均衡。</p><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><p>假设我们有三台机器<code>192.168.0.100</code>、<code>192.168.0.101</code>、<code>example.com</code>。<br>下面是一个简单的配置方法, <code>upstream</code>块必须在<code>http</code>块内。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream tomcats &#123;</span><br><span class="line">        server 192.168.0.100:8080;</span><br><span class="line">        server 192.168.0.101:8080;</span><br><span class="line">        server example.com:8080;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        # 1. 负载均衡, 首页单独处理, 加快速度</span><br><span class="line">        location = / &#123;</span><br><span class="line">            proxy_pass http://tomcats/index</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://tomcats</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认是以请求次数做轮询条件, 比如第一次请求, 则分配到<code>192.168.0.100:8080</code>, 第二次请求, 则分配到<code>192.168.0.101:8080</code>, 以此类推。</p><h2 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h2><p>追加到<code>server</code>后面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcats &#123;</span><br><span class="line">    server 192.168.0.100:8080;</span><br><span class="line">    server 192.168.0.101:8080 weight=2;</span><br><span class="line">    server example.com:8080 down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:center">配置</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>weight=2</code></td><td style="text-align:center">权重越高, 越容易被轮询到</td></tr><tr><td style="text-align:center"><code>down</code></td><td style="text-align:center">暂不参与负载均衡</td></tr><tr><td style="text-align:center"><code>backup</code></td><td style="text-align:center">预留的备份服务器, 当其他所有服务挂了的时候启用</td></tr><tr><td style="text-align:center"><code>max_fails=1</code></td><td style="text-align:center">允许请求失败的次数</td></tr><tr><td style="text-align:center"><code>fail_timeout=10s</code></td><td style="text-align:center">经过<code>max_fails</code>失败后, <code>server</code>暂停的时间, 默认<code>10s</code></td></tr><tr><td style="text-align:center"><code>max_conns=10</code></td><td style="text-align:center">限制最大的接收连接数</td></tr></tbody></table><h1 id="轮询策略"><a href="#轮询策略" class="headerlink" title="轮询策略"></a>轮询策略</h1><p>当然, 还有其他的轮询策略, 配置到<code>upstream</code>内即可。</p><table><thead><tr><th style="text-align:center">轮询策略</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">轮询(默认)</td><td style="text-align:center">按请求顺序分配到不同的<code>server</code></td></tr><tr><td style="text-align:center">加权轮询</td><td style="text-align:center"><code>weight</code>值越大, 分配到的访问几率越高</td></tr><tr><td style="text-align:center"><code>ip_hash</code></td><td style="text-align:center">每个请求按访问<code>IP</code>的<code>hash</code>结果分配, 同一个<code>IP</code>固定访问一个<code>server</code></td></tr><tr><td style="text-align:center"><code>url_hash</code></td><td style="text-align:center">按照访问的<code>URL</code>的<code>hash</code>结果分配, 同一个<code>URL</code>固定访问一个<code>server</code></td></tr><tr><td style="text-align:center"><code>least_conn</code></td><td style="text-align:center">最少链接数, 哪个<code>server</code>连接数少就分配给谁</td></tr><tr><td style="text-align:center"><code>hash关键数值</code></td><td style="text-align:center"><code>hash</code>自定义的<code>key</code>, <code>url_hash</code>是具体实现, 在<code>Nginx 1.7.2</code>后可用</td></tr></tbody></table><h2 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h2><p>用于需要对<code>Session</code>或<code>Cookie</code>保持一致的情况。<br>但是如果多台机器走同一个代理服务器, <code>Nginx</code>根据代理服务器的<code>IP</code>做<code>Hash</code>, 会导致多台服务器走的都是同一个<code>server</code>.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcats &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.0.100:8080;</span><br><span class="line">    server 192.168.0.101:8080;</span><br><span class="line">    server example.com:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h2><p><code>url_hash</code>是将<code>$request_uri</code>作为自定义<code>hash</code>的<code>key</code>。<br>注意, 自定义<code>hash key</code>只有在<code>Nginx 1.7.2</code>后可用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream tomcats &#123;</span><br><span class="line">    hash $request_uri;;</span><br><span class="line">    server 192.168.0.100:8080;</span><br><span class="line">    server 192.168.0.101:8080;</span><br><span class="line">    server example.com:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://blog.51cto.com/dmwing/1896879" target="_blank" rel="noopener">四层和七层负载均衡 - 详细总结</a></li></ul>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Nginx_Server_load_balancing_configuration.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用inotifytools监控文件</title>
      <link>https://ahaochan.github.io/posts/Monitor_files_with_inotifytools.html</link>
      <guid>https://ahaochan.github.io/posts/Monitor_files_with_inotifytools.html</guid>
      <pubDate>Wed, 15 Aug 2018 09:47:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;监控文件变化是一个很常用的功能, 比如监控密码文件, &lt;code&gt;html&lt;/code&gt;文件, 如果被恶意修改, 那就发送一个请求给服务器, 发送短信给管理员。&lt;br&gt;这里使用&lt;code&gt;inotify-tools&lt;/code&gt;来监控文件变化, 安装命令如下:&lt;br&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ yum install -y inotify-tools&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;inotify-tools&lt;/code&gt;提供了两个命令: &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;inotifywait&lt;/code&gt;, 它是用来监控文件或目录的变化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inotifywatch&lt;/code&gt;, 它是用来统计文件系统访问的次数&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>监控文件变化是一个很常用的功能, 比如监控密码文件, <code>html</code>文件, 如果被恶意修改, 那就发送一个请求给服务器, 发送短信给管理员。<br>这里使用<code>inotify-tools</code>来监控文件变化, 安装命令如下:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y inotify-tools</span><br></pre></td></tr></table></figure></p><p><code>inotify-tools</code>提供了两个命令: </p><ol><li><code>inotifywait</code>, 它是用来监控文件或目录的变化</li><li><code>inotifywatch</code>, 它是用来统计文件系统访问的次数</li></ol><a id="more"></a><h1 id="默认内核参数"><a href="#默认内核参数" class="headerlink" title="默认内核参数"></a>默认内核参数</h1><p>参数以文件形式存储</p><table><thead><tr><th style="text-align:center">文件路径</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>/proc/sys/fs/inotify/max_queued_evnets</code></td><td style="text-align:center">16384</td><td style="text-align:center">表示调用<code>inotify_init</code>时分配给<code>inotify instance</code>中可排队的<code>event</code>的数目的最大值，超出这个值的事件被丢弃，但会触发<code>IN_Q_OVERFLOW</code>事件。</td></tr><tr><td style="text-align:center"><code>/proc/sys/fs/inotify/max_user_instances</code></td><td style="text-align:center">128</td><td style="text-align:center">表示每一个real user <a href="http://man.linuxde.net/id" title="id命令" target="_blank" rel="noopener">id</a>可创建的<code>inotify instatnces</code>的数量上限</td></tr><tr><td style="text-align:center"><code>/proc/sys/fs/inotify/max_user_watches</code></td><td style="text-align:center">8192</td><td style="text-align:center">表示每个<code>inotify instatnces</code>可监控的最大目录数量。如果监控的文件数目巨大，需要根据情况，适当增加此值的大小。</td></tr></tbody></table><p>如修改每个<code>inotify instatnces</code>可监控的最大目录数量为<code>104857600</code><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 104857600 &gt; /proc/sys/fs/inotify/max_user_watches</span><br></pre></td></tr></table></figure></p><h1 id="inotifywait监控文件变化"><a href="#inotifywait监控文件变化" class="headerlink" title="inotifywait监控文件变化"></a>inotifywait监控文件变化</h1><p><strong>部分常用参数说明</strong></p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>-m, --monitor</code></td><td style="text-align:center">一直监听, 不指定则默认在第一个事件发生后结束</td></tr><tr><td style="text-align:center"><code>-r, --recursive</code></td><td style="text-align:center">使用递归形式监视目录, 注意监视文件的数量最多为<code>8192</code>, 要修改数量需要修改<code>max_user_watches</code>文件</td></tr><tr><td style="text-align:center"><code>-q, --quiet</code></td><td style="text-align:center">指定一次减少输出信息(仅打印事件), 指定两次不输出非错误信息</td></tr><tr><td style="text-align:center"><code>--timefmt</code></td><td style="text-align:center">指定时间的输出格式, 显示在<code>--format</code>的<code>%T</code>中, 格式参考<a href="http://www.cplusplus.com/reference/ctime/strftime/" target="_blank" rel="noopener">strftime函数</a></td></tr><tr><td style="text-align:center"><code>--format</code></td><td style="text-align:center">指定日志输出格式, <code>%w</code>表示发生事件的目录, <code>%f</code>表示发生事件的文件, <code>%e</code>表示发生的事件, <code>%Xe</code>事件名以<code>X</code>分隔, <code>%T</code>使用由<code>--timefmt</code>定义的时间格式</td></tr><tr><td style="text-align:center"><code>--event</code></td><td style="text-align:center">只监听某些事件, 事件参考<a href="http://man.linuxde.net/inotifywait" target="_blank" rel="noopener">可监听的事件</a></td></tr></tbody></table><p>先来个简单的例子, 监控<code>test</code>文件夹下的变化。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 在终端1开启inotifywait, -r表示递归监视, -m表示持续监视, -q表示只输出事件</span></span><br><span class="line">$ mkdir <span class="built_in">test</span></span><br><span class="line">$ inotify -rmq <span class="built_in">test</span>/</span><br><span class="line"><span class="comment"># 2. 在终端2写入文件</span></span><br><span class="line">$ <span class="built_in">echo</span> 123 &gt; <span class="built_in">test</span>/123.txt</span><br><span class="line"><span class="comment"># 3. 终端1显示如下信息</span></span><br><span class="line"><span class="built_in">test</span>/ CREATE 123.txt</span><br><span class="line"><span class="built_in">test</span>/ OPEN 123.txt</span><br><span class="line"><span class="built_in">test</span>/ MODIFY 123.txt</span><br><span class="line"><span class="built_in">test</span>/ CLOSE_WRITE,CLOSE 123.txt</span><br></pre></td></tr></table></figure></p><p>下面来一个复杂点的例子, 后台监控<code>test</code>文件夹变化, 并将变化内容发送到邮箱。(注意! 这种注释方式会<a href="https://stackoverflow.com/a/12797512/6335926" target="_blank" rel="noopener">损耗性能</a>! 这里只是为了直观才加的注释)<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在终端1操作</span></span><br><span class="line">$ vim inotify.sh</span><br><span class="line"><span class="comment">#/bin/bash</span></span><br><span class="line">/usr/bin/inotifywait -rmq               `<span class="comment"># 1. -r表示递归监视, -m表示持续监视, -q表示只输出事件` \</span></span><br><span class="line">   --timefmt <span class="string">'%Y-%m-%d %H:%M:%S'</span>        `<span class="comment"># 2. 时间格式为 2018-08-15 16:16:12` \</span></span><br><span class="line">   --format  <span class="string">'%T %w%f %e'</span>               `<span class="comment"># 3. 输出格式为: 时间 目录 文件 事件` \</span></span><br><span class="line">   --event modify,attrib,create,delete  `<span class="comment"># 4. 只监控特定事件` \</span></span><br><span class="line">   <span class="built_in">test</span>/                                `<span class="comment"># 5. 监控test文件夹` \</span></span><br><span class="line">   | <span class="keyword">while</span> <span class="built_in">read</span> <span class="built_in">log</span>; <span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$log</span> | mail -s <span class="string">'文件改变'</span> root; <span class="keyword">done</span>; `<span class="comment"># 6. 读取管道流, 执行发送邮件给 root 的命令`</span></span><br><span class="line"></span><br><span class="line">$ chmod 755 inotify.sh</span><br><span class="line">$ nohup inotify.sh &gt;&gt; /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端2操作</span></span><br><span class="line">$ <span class="built_in">echo</span> 123 &gt; <span class="built_in">test</span>/123.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端3操作, ctrl+D结束查看邮件</span></span><br><span class="line">$ mail</span><br><span class="line">Heirloom Mail version 12.5 7/5/10.  Type ? <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"><span class="string">"/var/spool/mail/root"</span>: 1 message 1 new</span><br><span class="line">&gt;N  1 root                  Wed Aug 15 17:14  18/697   <span class="string">"文件改变"</span></span><br><span class="line">&amp; Held 1 message <span class="keyword">in</span> /var/spool/mail/root</span><br></pre></td></tr></table></figure></p><h1 id="inotifywatch统计访问次数"><a href="#inotifywatch统计访问次数" class="headerlink" title="inotifywatch统计访问次数"></a>inotifywatch统计访问次数</h1><p>一个简单的例子, 监控<code>test</code>文件夹下<code>60s</code>内的变化次数<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inotifywatch -v -e modify,delete,create,attrib,move,open,close,access -e modify -t 60 -r <span class="built_in">test</span>/</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/martinzhang/p/4126907.html" target="_blank" rel="noopener">inotifywait命令</a></li><li><a href="http://linux.51yip.com/search/inotifywatch" target="_blank" rel="noopener">inotifywatch</a></li></ul>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Monitor_files_with_inotifytools.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx连接限制和访问控制</title>
      <link>https://ahaochan.github.io/posts/Nginx_connection_restrictions_and_access_control.html</link>
      <guid>https://ahaochan.github.io/posts/Nginx_connection_restrictions_and_access_control.html</guid>
      <pubDate>Wed, 08 Aug 2018 08:45:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Nginx&lt;/code&gt;自带的模块支持对并发请求数进行限制, 还有对请求来源进行限制。可以用来防止&lt;code&gt;DDOS&lt;/code&gt;攻击。&lt;br&gt;阅读本文须知道&lt;code&gt;nginx&lt;/code&gt;的配置文件结构和语法。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Nginx</code>自带的模块支持对并发请求数进行限制, 还有对请求来源进行限制。可以用来防止<code>DDOS</code>攻击。<br>阅读本文须知道<code>nginx</code>的配置文件结构和语法。</p><a id="more"></a><h1 id="连接限制-limit-conn-module"><a href="#连接限制-limit-conn-module" class="headerlink" title="连接限制 limit_conn_module"></a>连接限制 limit_conn_module</h1><p><code>limit_conn_module</code>: <code>TCP</code>连接频率限制, 一次<code>TCP</code>连接可以建立多次<code>HTTP</code>请求。<br>配置语法: </p><table><thead><tr><th style="text-align:center"><code>limit_conn_module</code>语法</th><th style="text-align:center">范围</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>limit_conn_zone 标识 zone=空间名:空间大小;</code></td><td style="text-align:center"><code>http</code></td><td style="text-align:center">用于声明一个存储空间</td></tr><tr><td style="text-align:center"><code>limit_conn 空间名 并发限制数;</code></td><td style="text-align:center"><code>http</code>、<code>server</code>或<code>location</code></td><td style="text-align:center">用于限制某个存储空间的并发数量</td></tr><tr><td style="text-align:center"><code>limit_conn_log_level 日志等级;</code></td><td style="text-align:center"><code>http</code>、<code>server</code>或<code>location</code></td><td style="text-align:center">当达到最大限制连接数后, 记录日志的等级</td></tr><tr><td style="text-align:center"><code>limit_conn_status 状态码;</code></td><td style="text-align:center"><code>http</code>、<code>server</code>或<code>location</code></td><td style="text-align:center">当超过限制后，返回的响应状态码，默认是<code>503</code></td></tr></tbody></table><p><code>limit_conn_zone</code>会声明一个<code>zone</code>空间来记录连接状态, 才能限制数量。<br><code>zone</code>是存储连接状态的空间, 以键值对存储, 通常以客户端地址<code>$binary_remote_addr</code>作为<code>key</code>来标识每一个连接。<br>当<code>zone</code>空间被耗尽，服务器将会对后续所有的请求返回<code>503(Service Temporarily Unavailable)</code> 错误。</p><h1 id="请求限制-limit-req-mudule"><a href="#请求限制-limit-req-mudule" class="headerlink" title="请求限制 limit_req_mudule"></a>请求限制 limit_req_mudule</h1><p><code>limit_req_mudule</code>: <code>HTTP</code>请求频率限制, 一次<code>TCP</code>连接可以建立多次<code>HTTP</code>请求。<br> 配置语法:</p><table><thead><tr><th style="text-align:center"><code>limit_req_mudule</code>语法</th><th style="text-align:center">范围</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>limit_req_zone key zone=空间名:空间大小 rate=每秒请求数;</code></td><td style="text-align:center"><code>http</code></td><td style="text-align:center">用于声明一个存储空间</td></tr><tr><td style="text-align:center"><code>limit_req zone=空间名 [burst=队列数] [nodelay];</code></td><td style="text-align:center"><code>http</code>、<code>server</code>或<code>location</code></td><td style="text-align:center">用于限制某个存储空间的并发数量</td></tr></tbody></table><p>这里的<code>zone</code>也是用来存储连接的一个空间。</p><h2 id="burst和nodelay"><a href="#burst和nodelay" class="headerlink" title="burst和nodelay"></a>burst和nodelay</h2><p><code>burst</code>和<code>nodelay</code>对并发请求设置了一个缓冲区和是否延迟处理的策略。<br>先假设有如下<code>zone</code>配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_req_zone $binan_remote_addr zone=req_zone:1m rate=10r/s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>情况1: <code>limit_req zone=req_zone;</code></p><ol><li>第<code>1</code>秒发送<code>10</code>个请求, 正常响应。</li><li>第<code>1</code>秒发送<code>13</code>个请求, 前<code>10</code>个请求正常响应, 后<code>3</code>个请求返回<code>503(Service Temporarily Unavailable)</code>。</li></ol><p>不加<code>brust</code>和<code>nodelay</code>的情况下, <code>rate=10r/s</code>每秒只能执行<code>10</code>次请求, 多的直接返回<code>503</code>错误。</p><hr><p>情况2: <code>limit_req zone=req_zone brust=5;</code></p><ol><li>第<code>1</code>秒发送<code>10</code>个请求, 正常响应。</li><li>第<code>1</code>秒发送<code>13</code>个请求, 前<code>10</code>个请求正常响应, 后<code>3</code>个请求放入<code>brust</code>等待响应。</li><li>第<code>1</code>秒发送<code>20</code>个请求, 前<code>10</code>个请求正常响应, 后<code>5</code>个请求放入<code>brust</code>等待响应, 最后<code>5</code>个请求返回<code>503(Service Temporarily Unavailable)</code>, 第<code>2</code>秒执行<code>brust</code>中的<code>5</code>个请求。</li><li>第<code>1</code>秒发送<code>20</code>个请求, 前<code>10</code>个请求正常响应, 后<code>5</code>个请求放入<code>brust</code>等待响应, 最后<code>5</code>个请求返回<code>503(Service Temporarily Unavailable)</code>, 第<code>2</code>秒发送<code>6</code>个请求, 执行<code>brust</code>中的<code>5</code>个请求, 将<code>5</code>个请求放入<code>brust</code>等待响应, 剩下的<code>1</code>个请求返回<code>503(Service Temporarily Unavailable)</code>。</li></ol><p>加<code>brust=5</code>不加<code>nodelay</code>的情况下, 有一个容量为<code>5</code>的缓冲区, <code>rate=10r/s</code>每秒只能执行<code>10</code>次请求, 多的放到缓冲区中, 如果缓冲区满了, 就直接返回<code>503</code>错误。而缓冲区在下一个时间段会取出请求进行响应, 如果还有请求进来, 则继续放缓冲区, 多的就返回<code>503</code>错误。</p><hr><p>情况3: <code>limit_req zone=req_zone brust=5 nodelay;</code></p><ol><li>第<code>1</code>秒发送<code>10</code>个请求, 正常响应。</li><li>第<code>1</code>秒发送<code>13</code>个请求, <code>13</code>个请求正常响应。</li><li>第<code>1</code>秒发送<code>20</code>个请求, 前<code>15</code>个请求正常响应, 后<code>5</code>个请求返回<code>503(Service Temporarily Unavailable)</code>。</li><li>第<code>1</code>秒发送<code>20</code>个请求, 前<code>15</code>个请求正常响应, 后<code>5</code>个请求返回<code>503(Service Temporarily Unavailable)</code>, 第<code>2</code>秒发送<code>6</code>个请求, 正常响应。</li></ol><p>加<code>brust=5</code>和<code>nodelay</code>的情况下, 有一个容量为<code>5</code>的缓冲区, <code>rate=10r/s</code>每秒能执行<code>15</code>次请求, <code>15=10+5</code>。多的直接返回<code>503</code>错误。 </p><hr><h1 id="基于IP的访问控制"><a href="#基于IP的访问控制" class="headerlink" title="基于IP的访问控制"></a>基于IP的访问控制</h1><p><code>http_access_module</code>: 基于<code>IP</code>的访问控制, 通过代理可以绕过限制, 防君子不防小人。</p><table><thead><tr><th style="text-align:center"><code>http_access_module</code>语法</th><th style="text-align:center">范围</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>allow IP地址 &amp;#124; CIDR网段 &amp;#124; unix: &amp;#124; all;</code></td><td style="text-align:center"><code>http</code>、<code>server</code>、<code>location</code>和<code>limit_except</code></td><td style="text-align:center">允许<code>IP地址</code>、<code>CIDR</code>格式的网段、<code>unix</code>套接字或所有来源访问</td></tr><tr><td style="text-align:center"><code>deny IP地址 &amp;#124; CIDR网段 &amp;#124; unix: &amp;#124; all;</code></td><td style="text-align:center"><code>http</code>、<code>server</code>、<code>location</code>和<code>limit_except</code></td><td style="text-align:center">禁止<code>IP地址</code>、<code>CIDR</code>格式的网段、<code>unix</code>套接字或所有来源访问</td></tr></tbody></table><p><code>allow</code>和<code>deny</code>会按照顺序, 从上往下, 找到第一个匹配规则, 判断是否允许访问, 所以一般把<code>all</code>放最后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    deny  192.168.1.1;</span><br><span class="line">    allow 192.168.1.0/24;</span><br><span class="line">    allow 10.1.1.0/16;</span><br><span class="line">    allow 2001:0db8::/32;</span><br><span class="line">    deny  all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="基于用户密码的访问控制"><a href="#基于用户密码的访问控制" class="headerlink" title="基于用户密码的访问控制"></a>基于用户密码的访问控制</h1><p><code>http_auth_basic_module</code>: 基于文件匹配用户密码的登录</p><table><thead><tr><th style="text-align:center"><code>http_auth_basic_module</code>语法</th><th style="text-align:center">范围</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>auth_basic 请输入你的帐号密码 &amp;#124; off;</code></td><td style="text-align:center"><code>http</code>、<code>server</code>、<code>location</code>和<code>limit_except</code></td><td style="text-align:center">显示用户登录提示(有些浏览器不显示提示)</td></tr><tr><td style="text-align:center"><code>auth_basic_user_file 存储帐号密码的文件路径;</code></td><td style="text-align:center"><code>http</code>、<code>server</code>、<code>location</code>和<code>limit_except</code></td><td style="text-align:center">从文件中匹配帐号密码</td></tr></tbody></table><p>密码文件可以通过<code>htpasswd</code>生成, <code>htpasswd</code>需要安装<code>yum install -y httpd-tools</code>。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c 创建新文件, -b在参数中直接输入密码</span></span><br><span class="line">$ htpasswd -bc /etc/nginx/conf.d/passwd user1 pw1</span><br><span class="line">Adding password <span class="keyword">for</span> user user1</span><br><span class="line">$ htpasswd -b /etc/nginx/conf.d/passwd user2 pw2</span><br><span class="line">Adding password <span class="keyword">for</span> user user2</span><br><span class="line">$ cat /etc/nginx/conf.d/passwd </span><br><span class="line">user1:<span class="variable">$apr1</span><span class="variable">$7v</span>/m0.IF<span class="variable">$2kpM9NVVxbAv</span>.jSUvUQr01</span><br><span class="line">user2:<span class="variable">$apr1</span><span class="variable">$XmoO4Zzy</span><span class="variable">$Df76U0Gzxbd7</span>.5vXE0UsE0</span><br></pre></td></tr></table></figure></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html" target="_blank" rel="noopener">limit_conn_module</a></li><li><a href="http://nginx.org/en/docs/http/ngx_http_limit_req_module.html" target="_blank" rel="noopener">limit_req_mudule</a></li><li><a href="http://nginx.org/en/docs/http/ngx_http_access_module.html" target="_blank" rel="noopener">http_access_module</a></li><li><a href="http://nginx.org/cn/docs/http/ngx_http_auth_basic_module.html" target="_blank" rel="noopener">http_auth_basic_module</a></li></ol>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Nginx_connection_restrictions_and_access_control.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>BandwagonHost推广获取佣金</title>
      <link>https://ahaochan.github.io/posts/How_to_get_Commission_of_Bandwagonhost.html</link>
      <guid>https://ahaochan.github.io/posts/How_to_get_Commission_of_Bandwagonhost.html</guid>
      <pubDate>Wed, 08 Aug 2018 04:51:23 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;BandwagonHost&lt;/code&gt;是一个国外的&lt;code&gt;VPS&lt;/code&gt;网站, 可以做一些在国内做不了的事情。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>BandwagonHost</code>是一个国外的<code>VPS</code>网站, 可以做一些在国内做不了的事情。</p><a id="more"></a><h1 id="如何获取推广链接"><a href="#如何获取推广链接" class="headerlink" title="如何获取推广链接"></a>如何获取推广链接</h1><p>首先你要注册一个帐号, 注意资料尽量真实, 貌似搬瓦工会检测你的<code>IP</code>来判断你是否在欺诈他。<br>然后访问<a href="https://bandwagonhost.com/affiliates.php" target="_blank" rel="noopener">自己的推广页面</a>。<br>可以看到一个推广链接, 下面是<a href="https://bandwagonhost.com/aff.php?aff=22459" target="_blank" rel="noopener">我的推广链接</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://bandwagonhost.com/aff.php?aff=22459</span><br></pre></td></tr></table></figure></p><p>还可以看到各种统计的数据</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">佣金百分比</td><td style="text-align:center">22%</td></tr><tr><td style="text-align:center">待定佣金</td><td style="text-align:center">$0.00 USD</td></tr><tr><td style="text-align:center">可提取佣金</td><td style="text-align:center">$0.00 USD</td></tr><tr><td style="text-align:center">支付总额</td><td style="text-align:center">$0.00 USD</td></tr></tbody></table><h2 id="获取单品推广链接"><a href="#获取单品推广链接" class="headerlink" title="获取单品推广链接"></a>获取单品推广链接</h2><p>但是上面的推广链接访问的是搬瓦工首页, 如果想直接推广某个<code>VPS</code>, 就需要自己写<code>url</code>。<br>比如最便宜的<code>10G VPS</code>, 它的<a href="https://bandwagonhost.com/cart.php?a=add&amp;pid=43" target="_blank" rel="noopener">商品链接</a>如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://bandwagonhost.com/cart.php?a=add&amp;pid=43</span><br></pre></td></tr></table></figure></p><p>我们只要在自己的推广链接后面加上<code>pid</code>参数即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://bandwagonhost.com/aff.php?aff=22459&amp;pid=43</span><br></pre></td></tr></table></figure></p><p>这样别人点你的推广链接, 并且购买成功, 你就可以获得一定比例的佣金, 比如上面写的<code>22%</code>。</p><h1 id="如何使用佣金"><a href="#如何使用佣金" class="headerlink" title="如何使用佣金"></a>如何使用佣金</h1><p>值得注意的是, 推广链接必须贴在<strong>网页</strong>上。不能私发, 不能<code>hack</code>别人。<br>在<a href="https://bandwagonhost.com/affiliates.php" target="_blank" rel="noopener">affiliates</a>提交提现申请即可。<br>选择<code>To account balance (to be used to pay for services)</code>用于下次续费。</p><p>默认等个两三天就可以提现成功, 如果没有成功, 可以发个<a href="https://bandwagonhost.com/supporttickets.php" target="_blank" rel="noopener">工单</a>。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如果你是第一次购买, 可以使用下我的<a href="https://bandwagonhost.com/cart.php?a=add&amp;pid=43" target="_blank" rel="noopener">推广链接</a>支持下我, 感激不尽。</p>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/How_to_get_Commission_of_Bandwagonhost.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Docker入门安装与运行</title>
      <link>https://ahaochan.github.io/posts/Docker_simple_installation_and_operation.html</link>
      <guid>https://ahaochan.github.io/posts/Docker_simple_installation_and_operation.html</guid>
      <pubDate>Thu, 19 Jul 2018 14:20:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;docker&lt;/code&gt;是一个存放应用的容器, 将下载、安装、运行等进行了规范化。&lt;br&gt;本文将在虚拟机中&lt;code&gt;CentOS&lt;/code&gt;使用桥接连接本机。关于桥接可以看我的另一篇文章, 上方搜索&lt;strong&gt;桥接&lt;/strong&gt;即可。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>docker</code>是一个存放应用的容器, 将下载、安装、运行等进行了规范化。<br>本文将在虚拟机中<code>CentOS</code>使用桥接连接本机。关于桥接可以看我的另一篇文章, 上方搜索<strong>桥接</strong>即可。</p><a id="more"></a><h1 id="CentOS7安装"><a href="#CentOS7安装" class="headerlink" title="CentOS7安装"></a>CentOS7安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># 1. 检查是否为root用户</span><br><span class="line">echo &quot;==================检查是否为root用户==================&quot;</span><br><span class="line">if [[ $&#123;EUID&#125; != 0 ]]; then</span><br><span class="line">    echo &quot;请切换到root用户&quot;;</span><br><span class="line">    exit 1;</span><br><span class="line">fi;</span><br><span class="line">echo &quot;当前用户是root&quot;</span><br><span class="line"></span><br><span class="line"># 2. 检查内核版本号大于3.10</span><br><span class="line">echo &quot;==================检查内核版本号大于3.10==================&quot;</span><br><span class="line">status=$(uname -r | awk -F &apos;.&apos; &apos;&#123;if($1&gt;=3&amp;&amp;$2&gt;=10) &#123;print &quot;0&quot;&#125; else &#123; print &quot;1&quot;&#125;&#125;&apos;)</span><br><span class="line">if [[ $&#123;status&#125; != 0 ]]; then</span><br><span class="line">    echo &quot;Kernel version must be &gt;= 3.10, you version is $(uname -r)&quot;</span><br><span class="line">    exit 1;</span><br><span class="line">fi;</span><br><span class="line">echo &quot;当前内核版本号是$(uname -r)&quot;</span><br><span class="line"></span><br><span class="line"># 3. 删除旧版本docker</span><br><span class="line">echo &quot;==================删除旧版本docker==================&quot;</span><br><span class="line">yum remove docker docker-common docker-selinux docker-engine</span><br><span class="line"></span><br><span class="line"># 4. yum-util提供yum-config-manager功能, 另外两个是devicemapper驱动依赖的</span><br><span class="line">echo &quot;==================安装相关依赖==================&quot;</span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"># 5. 设置yum源</span><br><span class="line">echo &quot;==================设置yum源==================&quot;</span><br><span class="line">yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 6. 安装docker并启动</span><br><span class="line">echo &quot;==================安装docker==================&quot;</span><br><span class="line">yum install -y docker-ce</span><br><span class="line">service docker start</span><br><span class="line"></span><br><span class="line"># 7. 验证是否安装成功</span><br><span class="line">echo &quot;==================验证是否安装成功==================&quot;</span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><h1 id="安装运行Hello-World"><a href="#安装运行Hello-World" class="headerlink" title="安装运行Hello World"></a>安装运行Hello World</h1><p><code>docker</code>包含几个命令, <code>docker pull</code>下载, <code>docker images</code>查看镜像, <code>docker run</code> 运行。<br>这是一个<code>hello world</code>程序, <a href="https://hub.docker.com/_/hello-world/" target="_blank" rel="noopener">docker hub 地址</a><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 从仓库下载hello-world</span></span><br><span class="line">$ docker pull hello-world</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">9db2ca6ccae0: Pull complete </span><br><span class="line">Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdc</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看已有镜像</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world         latest              2cb0d9787c4d        5 days ago          1.85kB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 运行 hello world, 打印如下信息</span></span><br><span class="line">$ docker run hello-world</span><br><span class="line">来自Docker的问好!</span><br><span class="line">此消息表示您的安装似乎正常工作。</span><br><span class="line"></span><br><span class="line">为了生成这些信息, Docker进行了以下的操作:</span><br><span class="line"> 1. Docker客户端 连接到 Docker daemon守护进程</span><br><span class="line"> 2. Docker daemon守护进程 从 Docker 仓库 下载(pull) 了 hello-world 镜像(image)</span><br><span class="line"> 3. Docker daemon守护进程从该镜像(image)创建了一个新容器(container)，该容器运行并执行可执行文件, 输出您现在看到的内容。</span><br><span class="line"> 4. Docker daemon守护进程将输出流输出到Docker客户端, Docker客户端会将信息发送到你的终端(terminal)</span><br></pre></td></tr></table></figure></p><p>执行操作: </p><ol><li><code>docker client</code>客户端向<code>docker daemon</code>服务端发送<code>docker run</code>命令</li><li><code>docker daemon</code>检查是否有<code>image</code>镜像, 没有则向<code>docker hub</code>仓库下载<code>image</code>镜像</li><li><code>docker daemon</code>会创建一个<code>container</code>容器运行这个<code>image</code>镜像</li></ol><h1 id="安装运行Nginx"><a href="#安装运行Nginx" class="headerlink" title="安装运行Nginx"></a>安装运行Nginx</h1><p>先安装<code>docker pull nginx</code>, 然后运行<code>docker run -dp 8080:80 nginx</code>。</p><ol><li><code>-d</code>: 后台运行容器, 并返回容器ID</li><li><code>-p</code>: 进行端口映射, 格式为: <code>主机端口:容器端口</code></li></ol><p>然后我们就可以在自己电脑输入<code>http://ip地址:8080</code>访问到<code>nginx</code>。</p><h2 id="WARNING-IPv4-forwarding-is-disabled-Networking-will-not-work"><a href="#WARNING-IPv4-forwarding-is-disabled-Networking-will-not-work" class="headerlink" title="WARNING: IPv4 forwarding is disabled. Networking will not work."></a>WARNING: IPv4 forwarding is disabled. Networking will not work.</h2><p>如果提示<code>IPv4</code>转发没有开启, 那就去开启。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"net.ipv4.ip_forward=1"</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">$ systemctl restart network</span><br></pre></td></tr></table></figure></p><h2 id="为什么要做端口映射"><a href="#为什么要做端口映射" class="headerlink" title="为什么要做端口映射?"></a>为什么要做端口映射?</h2><p><code>Docker</code>容器可以看成是一个<code>虚拟机</code>, 那我们的3台机器就有这种关系<br><img src="https://yuml.me/diagram/nofunky/class/[win10%E7%9C%9F%E6%AD%A3%E7%9A%84%E4%B8%BB%E6%9C%BA]-%3E[CentOS7%E8%99%9A%E6%8B%9F%E6%9C%BA],[CentOS7%E8%99%9A%E6%8B%9F%E6%9C%BA]-%3E[Docker%20Nginx%E5%AE%B9%E5%99%A8]" alt="主机关系"></p><p>如果是直接安装在<code>CentOS7虚拟机</code>上的话, 我们的<code>win10真正的主机</code>是可以直接访问<code>Nginx</code>的。 但是现在是运行在<code>Docker</code>容器里, 中间隔了个<code>CentOS7虚拟机</code>, 我们就需要做端口映射, 如<code>docker run -dp 8080:80 nginx</code>。</p><p>这样我们在<code>win10真正的主机</code>访问<code>CentOS7虚拟机</code>的<code>8080</code>端口时, <code>CentOS7虚拟机</code>会转发到<code>Docker</code>容器的<code>80</code>端口(这也是之前我们为什么要开启<code>IPv4</code>转发的原因)，我们就可以在<code>win10真正的主机</code>间接访问<code>Docker</code>容器中的<code>Nginx</code>了。</p><p><strong>注意</strong><br>实际最好端口要一致, 这里为了容易区分, 才分为<code>8080:80</code>, 最好为<code>80:80</code>。</p><h2 id="修改Nginx配置文件"><a href="#修改Nginx配置文件" class="headerlink" title="修改Nginx配置文件"></a>修改Nginx配置文件</h2><p><code>Docker</code>容器就像一个虚拟机, 所以我们也可以通过<code>bash</code>进入。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 后台启动nginx, 映射虚拟机端口8080到容器端口80</span></span><br><span class="line">[root@localhost ~]$ docker run -dp 8080:80 nginx</span><br><span class="line">0df7493162a1e34d43c74e67b1bbe4c810ea821a994d85d5d45eae837d4ddf25</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看docker进程, 找到nginx的容器id</span></span><br><span class="line">[root@localhost ~]$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">0df7493162a1        nginx               <span class="string">"nginx -g 'daemon of…"</span>   6 seconds ago       Up 5 seconds        0.0.0.0:8080-&gt;80/tcp   naughty_kilby</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 执行bash命令进入docker容器内部</span></span><br><span class="line">[root@localhost ~]$ docker <span class="built_in">exec</span> -it 0df7493162a1 bash</span><br><span class="line"><span class="comment"># -i 让容器的标准输入保持打开</span></span><br><span class="line"><span class="comment"># -t 让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上</span></span><br><span class="line">root@0df7493162a1:/$ vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></p><p>进入容器, 就可以像普通的<code>Linux</code>一样进行操作了, 如编辑配置文件<code>vim /etc/nginx/nginx.conf</code>。</p>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Docker_simple_installation_and_operation.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux打包压缩tar常用命令</title>
      <link>https://ahaochan.github.io/posts/Linux_package_compression_common_tar_commands.html</link>
      <guid>https://ahaochan.github.io/posts/Linux_package_compression_common_tar_commands.html</guid>
      <pubDate>Thu, 12 Jul 2018 16:03:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;打包存在的意义&quot;&gt;&lt;a href=&quot;#打包存在的意义&quot; class=&quot;headerlink&quot; title=&quot;打包存在的意义&quot;&gt;&lt;/a&gt;打包存在的意义&lt;/h1&gt;&lt;p&gt;打包是把多个文件变成一个文件。&lt;br&gt;压缩是把一个大文件变成小文件。&lt;br&gt;那么要把多个文件压缩成小文件, 就只能曲线救国, 先把多个文件打包成一个文件, 然后再对这个文件进行压缩。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="打包存在的意义"><a href="#打包存在的意义" class="headerlink" title="打包存在的意义"></a>打包存在的意义</h1><p>打包是把多个文件变成一个文件。<br>压缩是把一个大文件变成小文件。<br>那么要把多个文件压缩成小文件, 就只能曲线救国, 先把多个文件打包成一个文件, 然后再对这个文件进行压缩。</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="tar"><a href="#tar" class="headerlink" title=".tar"></a>.tar</h2><p>解包：<code>tar xvf FileName.tar</code><br>打包：<code>tar cvf FileName.tar DirName</code></p><h2 id="gz"><a href="#gz" class="headerlink" title=".gz"></a>.gz</h2><p>解压1：<code>gunzip FileName.gz</code><br>解压2：<code>gzip -d FileName.gz</code><br>压缩：<code>gzip FileName</code></p><h2 id="tar-gz-和-tgz"><a href="#tar-gz-和-tgz" class="headerlink" title=".tar.gz 和 .tgz"></a>.tar.gz 和 .tgz</h2><p>解压：<code>tar zxvf FileName.tar.gz</code><br>压缩：<code>tar zcvf FileName.tar.gz DirName</code></p><h2 id="bz2"><a href="#bz2" class="headerlink" title=".bz2"></a>.bz2</h2><p>解压1：<code>bzip2 -d FileName.bz2</code><br>解压2：<code>bunzip2 FileName.bz2</code><br>压缩： <code>bzip2 -z FileName</code></p><h2 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title=".tar.bz2"></a>.tar.bz2</h2><p>解压：<code>tar jxvf FileName.tar.bz2</code><br>压缩：<code>tar jcvf FileName.tar.bz2 DirName</code></p><h2 id="Z"><a href="#Z" class="headerlink" title=".Z"></a>.Z</h2><p>安装：<code>yum install -y ncompress</code><br>解压：<code>uncompress FileName.Z</code><br>压缩：<code>compress FileName</code></p><h2 id="tar-Z"><a href="#tar-Z" class="headerlink" title=".tar.Z"></a>.tar.Z</h2><p>安装：<code>yum install -y ncompress</code><br>解压：<code>tar Zxvf FileName.tar.Z</code><br>压缩：<code>tar Zcvf FileName.tar.Z DirName</code></p><h2 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h2><p>安装：<code>yum install -y zip</code><br>解压：<code>unzip FileName.zip</code><br>压缩：<code>zip FileName.zip DirName</code></p><h2 id="rar"><a href="#rar" class="headerlink" title=".rar"></a>.rar</h2><p>解压：<code>rar x FileName.rar</code><br>压缩：<code>rar a FileName.rar DirName</code></p><h2 id="rpm"><a href="#rpm" class="headerlink" title=".rpm"></a>.rpm</h2><p>解包：<code>rpm2cpio FileName.rpm | cpio -div</code></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.cnblogs.com/eoiioe/archive/2008/09/20/1294681.html" target="_blank" rel="noopener">linux下解压命令大全</a></li></ul>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Linux_package_compression_common_tar_commands.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx的location配置</title>
      <link>https://ahaochan.github.io/posts/Nginx_location_configuration.html</link>
      <guid>https://ahaochan.github.io/posts/Nginx_location_configuration.html</guid>
      <pubDate>Sun, 08 Jul 2018 10:42:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;location&lt;/code&gt;匹配到的&lt;code&gt;url&lt;/code&gt;可以执行特定的操作, 比如拦截, 转发。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>location</code>匹配到的<code>url</code>可以执行特定的操作, 比如拦截, 转发。</p><a id="more"></a><h1 id="url匹配"><a href="#url匹配" class="headerlink" title="url匹配"></a>url匹配</h1><p>语法:<br><code>location [=|~|~*|^~|@] uri { 配置 }</code><br><code>location</code>的<code>url</code>匹配遵循最长匹配原则。</p><table><thead><tr><th style="text-align:center">modifier</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">精确匹配, 和这个<code>url</code>完全一样的会被匹配到</td></tr><tr><td style="text-align:center">^~</td><td style="text-align:center">前缀匹配, 以这个<code>url</code>开头都会被匹配到</td></tr><tr><td style="text-align:center">~</td><td style="text-align:center">表示执行一个正则匹配，区分大小写</td></tr><tr><td style="text-align:center">~*</td><td style="text-align:center">表示执行一个正则匹配，不区分大小写</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">什么都没有, 就说明以这个<code>uri</code>开头的都会被匹配到</td></tr><tr><td style="text-align:center">@</td><td style="text-align:center">“@” 定义一个命名的 location，使用在内部定向时使用，例如 error_page, try_files</td></tr></tbody></table><p>匹配步骤:</p><ol><li>将所有的非正则匹配规则放入<strong>排序三叉树</strong>中, 正则匹配规则放入一个顺序队列(按配置文件书写顺序排序)中。</li><li>在三叉树中匹配<code>url</code>。如果匹配到<code>location =</code>就停止搜索。如果是前缀匹配<code>location ^~</code>或默认规则<code>location</code>则找到最长匹配。</li><li>再在正则匹配规则队列中匹配<code>url</code>, 如果有, 则使用这个正则匹配, 没有则使用三叉树中找到的匹配规则。</li></ol><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>上面说这么多, 还是得看例子来理解, 等看完例子再回过头去看上面的详细说明。<br><a href="https://detailyang.github.io/nginx-location-match-visible/" target="_blank" rel="noopener">nginx-location-match-visible</a>提供了一个可视化的匹配步骤。<br>将下面规则复制到其中, 即可查看匹配步骤和匹配结果。</p><h2 id="和-none-的区别"><a href="#和-none-的区别" class="headerlink" title="= 和 none 的区别"></a>= 和 none 的区别</h2><p>匹配规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;&#125;      # A</span><br><span class="line">location = / &#123;&#125;    # B</span><br><span class="line">location = /123 &#123;&#125; # C</span><br></pre></td></tr></table></figure></p><p>测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/      # 匹配B</span><br><span class="line">/123   # 匹配C</span><br></pre></td></tr></table></figure></p><p>##　~ 正则(区分大小写)<br>匹配规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;&#125;                           # A</span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;&#125;   # B</span><br><span class="line">location ~ \.(GIF|JPG|PNG|JS|CSS)$ &#123;&#125;   # C</span><br></pre></td></tr></table></figure></p><p>测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/       # 匹配A</span><br><span class="line">/a.jpg  # 匹配B</span><br><span class="line">/a.JPG  # 匹配C</span><br></pre></td></tr></table></figure></p><h2 id="正则-不区分大小写"><a href="#正则-不区分大小写" class="headerlink" title="~ 正则(不区分大小写)"></a>~ 正则(不区分大小写)</h2><p>匹配规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;&#125;                            # A</span><br><span class="line">location ~* \.(gif|jpg|png|js|css)$ &#123;&#125;   # B</span><br></pre></td></tr></table></figure></p><p>测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/       # 匹配A</span><br><span class="line">/a.jpg  # 匹配B</span><br><span class="line">/a.JPG  # 匹配B, 注意!! nginx-location-match-visible 有误! 实际是匹配到B的!</span><br></pre></td></tr></table></figure></p><h2 id=""><a href="#" class="headerlink" title="@"></a>@</h2><p><code>@</code>常用于内部跳转<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location ~* \.(gif|jpg|png|js|css)$ &#123;</span><br><span class="line">    error_page 404 @img_err</span><br><span class="line">&#125;</span><br><span class="line">location @img_err &#123;</span><br><span class="line">    # 规则</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="复合"><a href="#复合" class="headerlink" title="复合"></a>复合</h2><p>匹配规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location = / &#123;&#125;                         # A</span><br><span class="line">location = /login &#123;&#125;                    # B</span><br><span class="line">location ^~ /static/ &#123;&#125;                 # C</span><br><span class="line">location ~ \.(gif|jpg|png|js|css)$ &#123;&#125;   # D</span><br><span class="line">location ~* \.png$ &#123;&#125;                   # E</span><br><span class="line">location / &#123;&#125;                           # F</span><br></pre></td></tr></table></figure></p><p>测试用例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/                   # 匹配F</span><br><span class="line">/login              # 匹配B</span><br><span class="line">/static             # 匹配F</span><br><span class="line">/static/a           # 匹配C</span><br><span class="line">/test.png           # 匹配D</span><br><span class="line">/static.png         # 匹配D</span><br><span class="line">/test.PNG           # 匹配E, 注意!! nginx-location-match-visible 有误! 实际是匹配到E的!</span><br><span class="line">/static/a.png       # 匹配C</span><br><span class="line">/static/a.gif       # 匹配C</span><br></pre></td></tr></table></figure></p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>一般把<code>Nginx</code>作为负载均衡服务器, 静态资源可以存在<code>Nginx</code>服务器。<br>负载均衡配置本文不详细讲, 简单的说就像是买卖房屋的中介, 给你(客户端)介绍一个好的(连接的上的)房屋(服务端)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    upstream tomcats &#123;</span><br><span class="line">        server 192.168.0.100:8080;</span><br><span class="line">        server 192.168.0.101:8080;</span><br><span class="line">        server example.com:8080;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        # 1. 静态文件处理 参照另一篇文章, 这里简单的列举一下</span><br><span class="line">        location ^~ /static/ &#123;</span><br><span class="line">            root /webroot/static/;</span><br><span class="line">        &#125;</span><br><span class="line">        location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">            root /webroot/res/;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        # 2. 负载均衡, 首页单独处理, 加快速度</span><br><span class="line">        location = / &#123;</span><br><span class="line">            proxy_pass http://tomcats/index</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://tomcats</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Nginx_location_configuration.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx日志配置</title>
      <link>https://ahaochan.github.io/posts/Nginx_log_configuration.html</link>
      <guid>https://ahaochan.github.io/posts/Nginx_log_configuration.html</guid>
      <pubDate>Sun, 08 Jul 2018 10:42:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;日志输出配置&quot;&gt;&lt;a href=&quot;#日志输出配置&quot; class=&quot;headerlink&quot; title=&quot;日志输出配置&quot;&gt;&lt;/a&gt;日志输出配置&lt;/h1&gt;&lt;p&gt;&lt;code&gt;nginx&lt;/code&gt;的日志有两种&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;error_log&lt;/code&gt;: 记录服务器错误, 配置在&lt;strong&gt;全局&lt;/strong&gt;范围&lt;/li&gt;
&lt;li&gt;&lt;code&gt;access_log&lt;/code&gt;: 记录每一次请求访问, 配置在&lt;code&gt;http&lt;/code&gt;范围&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="日志输出配置"><a href="#日志输出配置" class="headerlink" title="日志输出配置"></a>日志输出配置</h1><p><code>nginx</code>的日志有两种</p><ol><li><code>error_log</code>: 记录服务器错误, 配置在<strong>全局</strong>范围</li><li><code>access_log</code>: 记录每一次请求访问, 配置在<code>http</code>范围</li></ol><a id="more"></a><p>日志配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 1. error.log日志配置</span><br><span class="line"># error_log  日志存储位置  错误日志级别;</span><br><span class="line">error_log  /var/log/nginx/error.log warn;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    # 2. access.log日志配置</span><br><span class="line">    # access_log  日志存储位置  日志格式名;</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">    # log_format 日志格式名 [escape=default|json] 参数字符串;</span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h1><p>语法: <code>log_format 日志格式名 [escape=default|json] string ...;</code><br>日志格式可以携带一些内置的变量, 如<code>IP地址</code>之类的。</p><h2 id="HTTP请求变量"><a href="#HTTP请求变量" class="headerlink" title="HTTP请求变量"></a>HTTP请求变量</h2><ol><li><code>arg_PARANERER</code>: 请求参数</li><li><code>http_HEADER</code>: 请求头</li><li><code>sent_HEADER</code>: 响应头</li></ol><p><code>Nginx</code>支持参数、请求头和响应头, 只要把字母转成小写, 横线转为下划线, 再加上<code>arg</code>、<code>http</code>或<code>sent</code>的前缀即可。<br>比如请求头的<code>User-Agent</code>, 对应的变量为<code>http_user_agent</code>。 </p><h2 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h2><p><a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#variables" target="_blank" rel="noopener">Nginx http core模块的变量</a><br>这里只介绍<code>nginx.conf</code>中默认配置的变量</p><ol><li><code>$remote_addr</code>: 客户端地址, 如<code>192.168.1.7</code></li><li><code>$remote_user</code>: 随基本身份验证提供的用户名</li><li><code>$time_local</code>: 通用日志格式的本地时间, 如<code>07/Jul/2018:15:33:14 +0800</code></li><li><code>$request</code>: 完整原始的请求行, 如<code>GET / HTTP/1.1</code></li><li><code>$status</code>: 响应状态码, 如<code>200</code>、<code>404</code></li><li><code>$body_bytes_sent</code>: 发送到客户端的字节数，不包括响应头</li></ol><h2 id="自定义变量"><a href="#自定义变量" class="headerlink" title="自定义变量"></a>自定义变量</h2><p><code>set</code>只能配置在<code>server</code>、<code>location</code>和<code>if</code>中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    set $变量名 &quot;变量值&quot;</span><br><span class="line">    location / &#123;</span><br><span class="line">        set $变量名 &quot;变量值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Nginx_log_configuration.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>toArray和toArray(T[])的不同</title>
      <link>https://ahaochan.github.io/posts/Difference_between_toArray(T%5B%5Da)_and_toArray().html</link>
      <guid>https://ahaochan.github.io/posts/Difference_between_toArray(T%5B%5Da)_and_toArray().html</guid>
      <pubDate>Sun, 08 Jul 2018 05:05:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Collection&lt;/code&gt;接口有两个方法&lt;code&gt;Object[] toArray();&lt;/code&gt;和&lt;code&gt;&amp;lt;T&amp;gt; T[] toArray(T[] a);&lt;/code&gt;, 可以用来将集合转为数组。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>Collection</code>接口有两个方法<code>Object[] toArray();</code>和<code>&lt;T&gt; T[] toArray(T[] a);</code>, 可以用来将集合转为数组。</p><a id="more"></a><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>一个返回<code>Object[]</code>, 一个返回<code>T[]</code>, 为了避免发生强制转化, 我们一般都是使用<code>&lt;T&gt; T[] toArray(T[] a);</code>。<br>而<code>&lt;T&gt; T[] toArray(T[] a);</code>传入的数组大小可以直接填<code>0</code>, 当然也可以直接填<code>source.size()</code>。<br>但是<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/" target="_blank" rel="noopener">arrays-wisdom-ancients</a>这篇文章做了分析, <code>JDK6</code>以后直接填<code>0</code>性能更好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; source = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 填充数据</span></span><br><span class="line">String[] array1 = (Object[]) source.toArray();</span><br><span class="line">String[] array2 = source.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">String[] array3 = source.toArray(<span class="keyword">new</span> String[source.size()]);</span><br></pre></td></tr></table></figure><h1 id="查看ArrayList的实现"><a href="#查看ArrayList的实现" class="headerlink" title="查看ArrayList的实现"></a>查看ArrayList的实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// Make a new array of a's runtime type, but my contents:</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arrays</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">            ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用<code>ArrayList.toArray</code>方法的时候, 都会调用<code>Arrays.copyOf</code>方法, 最终调用<code>System.arraycopy</code>方法, 这是一个<code>native</code>方法。<br>当然, 不同的集合有不同的<code>toArray</code>实现方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果传入的参数<code>toArray(T[] a)</code>小于本身的长度, 会<code>new</code>或者反射创建一个新的数组, 然后将元素复制进去。<br>但是<a href="https://shipilev.net/blog/2016/arrays-wisdom-ancients/" target="_blank" rel="noopener">arrays-wisdom-ancients</a>这篇文章做了分析, <code>JDK6</code>以后直接填<code>0</code>性能更好。</p>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Difference_between_toArray(T%5B%5Da)_and_toArray().html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Linux前后台程序管理</title>
      <link>https://ahaochan.github.io/posts/Linux_front_end_program_management.html</link>
      <guid>https://ahaochan.github.io/posts/Linux_front_end_program_management.html</guid>
      <pubDate>Sat, 07 Jul 2018 07:23:46 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;比如我打开电脑登录了&lt;code&gt;administrator&lt;/code&gt;用户, 打开&lt;code&gt;QQ&lt;/code&gt;, 微信, 然后开始下载游戏, 看视频。&lt;br&gt;我在看视频, 那么这个视频就是在前台运行的, 而下载游戏, 我不需要看它是怎么下载的, 所以放到后台执行, 这个就是前后台的应用场景。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>比如我打开电脑登录了<code>administrator</code>用户, 打开<code>QQ</code>, 微信, 然后开始下载游戏, 看视频。<br>我在看视频, 那么这个视频就是在前台运行的, 而下载游戏, 我不需要看它是怎么下载的, 所以放到后台执行, 这个就是前后台的应用场景。</p><a id="more"></a><h1 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h1><ol><li><code>命令; Ctrl+z</code>: 执行命令后, 按住<code>Ctrl+z</code>,将命令切换到后台<strong>暂停</strong>。</li><li><code>命令 &gt; /tmp/log.txt 2&gt;&amp;1 &amp;</code>: 将命令放到后台执行, 注意要将输出信息重定向, 否则会污染前台操作</li><li><code>bg %jobNumber</code>: 将某个后台程序放到后台<strong>运行</strong>。</li><li><code>jobs -l</code>: 查看所有的后台程序, <code>-l</code>显示PID。</li><li><code>fg %jobNumber</code>: 将某个后台程序放到前台运行。</li><li><code>kill -9 %jobNumber</code>: 将某个后台程序<strong>强制</strong>结束运行。</li><li><code>kill -15 %jobNumber</code>: 将某个后台程序<strong>正常</strong>结束运行。</li><li><code>nohup 命令 &amp;</code>: 将某个后台程序放到系统后台运行, 注销登录不会终止程序。</li></ol><h1 id="jobs-l"><a href="#jobs-l" class="headerlink" title="jobs -l"></a>jobs -l</h1><p><code>$ jobs [-lrs]</code>可以查看所有的后台程序。<br>选项与参数：<br><code>-l</code>  ：除了列出 <code>job number</code> 与命令串之外，同时列出 <code>PID</code> 的号码；<br><code>-r</code>  ：仅列出正在背景 <code>run</code> 的工作；<br><code>-s</code>  ：仅列出正在背景当中暂停 (<code>stop</code>) 的工作。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">jobs</span> -l</span><br><span class="line">[1]- 10314 Stopped                 vim ~/.bashrc</span><br><span class="line">[2]+ 10833 Stopped                 find / -<span class="built_in">print</span></span><br></pre></td></tr></table></figure></p><p><code>[1]</code>和<code>[2]</code>表示的是<code>jobNumber</code>, 作为<code>fg</code>、<code>bg</code>、<code>kill</code>命令的参数。<br><code>+</code>表示最近一个暂停的程序, <code>-</code>表示倒数第二个暂停的任务, 其他的不显示<code>+</code>和<code>-</code>。</p><h1 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. Ctrl+Z跳到后台暂停</span></span><br><span class="line">$ vim ~/test.txt</span><br><span class="line">123</span><br><span class="line"><span class="comment"># 按Ctrl+z</span></span><br><span class="line">[1]+  已停止               vim ~/test.tx<span class="comment"># 2. vim跳到前台执行</span></span><br><span class="line">$ <span class="built_in">fg</span> %1</span><br><span class="line"><span class="comment"># 3. 后台执行</span></span><br><span class="line">$ tar -zpcvf /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1 &amp;</span><br><span class="line">[1] 5143</span><br><span class="line"><span class="comment"># 一段时间后, 执行完毕</span></span><br><span class="line">[1]+  完成                  tar -zpcvf /tmp/etc.tar.gz /etc &gt; /tmp/log.txt 2&gt;&amp;1</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/Linux_front_end_program_management.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>长城宽带拒退光猫押金</title>
      <link>https://ahaochan.github.io/posts/The_Great_Wall_Broadband_refused_to_refund_the_deposit.html</link>
      <guid>https://ahaochan.github.io/posts/The_Great_Wall_Broadband_refused_to_refund_the_deposit.html</guid>
      <pubDate>Sat, 07 Jul 2018 06:11:00 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;长城宽带是真的坑, 没想到被我遇上了, 这里记录下。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>长城宽带是真的坑, 没想到被我遇上了, 这里记录下。</p><a id="more"></a><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>2017年10月13日, 家里断网了, 我拨打长城宽带客服电话<code>95079</code>咨询, 得知我所在地在进行三线合一工程, 要求使用光猫才能上网。<br>不接光猫就上不了网。<br>行吧, 赶紧催长城宽带过来装光猫。</p><p>2017年10月14日, 长城宽带工作人员范某某<!-- 范杰彬 -->(工号<code>14041</code>, 现已离职), 来我家装光猫。<br>说要交<code>200</code>押金, 我就问交押金到时怎么退押金, 重点来了, 他说只要带<code>开户人身份证</code>和<code>开户人手机号</code>过去, 就可以退押金了。<br>于是在没有收到收据的情况下, 交给他<code>200</code>元光猫押金。</p><h1 id="口头承诺都是屁-白纸黑字才是理"><a href="#口头承诺都是屁-白纸黑字才是理" class="headerlink" title="口头承诺都是屁, 白纸黑字才是理"></a>口头承诺都是屁, 白纸黑字才是理</h1><p>2018年6月, 家里要换电信, 我去打电话准备办光猫退押金手续。<br>结果长城宽带就开始表演了, 说是后台查不到我的记录, 要我提供押金单, 但是这不存在的押金单根本没有给我。<br>打电话打了几天, 都是在扯皮, 一副你没有押金单, 就不给你退的嘴脸。</p><h1 id="投诉之路"><a href="#投诉之路" class="headerlink" title="投诉之路"></a>投诉之路</h1><ol><li>(失败) <a href="http://web.sicq.org/" target="_blank" rel="noopener">深圳市消费者委员会消费维权公共服务平台</a>, 长城宽带要求我提供本不存在的单据才能退款, 和解失败。</li><li>(完结) 离职工作人员范某某联系我说愿意以<code>100</code>元回收光猫, 迫于没有单据证明, 只好妥协。</li></ol><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>原价<code>200</code>的光猫最后只收到<code>100</code>元。</p><h1 id="人生经验"><a href="#人生经验" class="headerlink" title="人生经验"></a>人生经验</h1><p>以后做什么事, 无论是工作合同, 还是买卖东西, 银行取款什么的, 都要白纸黑字写的一清二楚, 不给的话就不弄。</p>]]></content:encoded>
      
      <comments>https://ahaochan.github.io/posts/The_Great_Wall_Broadband_refused_to_refund_the_deposit.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
